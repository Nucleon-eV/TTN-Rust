// This file is generated by rust-protobuf 2.6.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct DeviceIdentifier {
    // message fields
    pub app_eui: ::std::vec::Vec<u8>,
    pub dev_eui: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeviceIdentifier {
    fn default() -> &'a DeviceIdentifier {
        <DeviceIdentifier as ::protobuf::Message>::default_instance()
    }
}

impl DeviceIdentifier {
    pub fn new() -> DeviceIdentifier {
        ::std::default::Default::default()
    }

    // bytes app_eui = 1;


    pub fn get_app_eui(&self) -> &[u8] {
        &self.app_eui
    }
    pub fn clear_app_eui(&mut self) {
        self.app_eui.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_eui(&mut self, v: ::std::vec::Vec<u8>) {
        self.app_eui = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_eui(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.app_eui
    }

    // Take field
    pub fn take_app_eui(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.app_eui, ::std::vec::Vec::new())
    }

    // bytes dev_eui = 2;


    pub fn get_dev_eui(&self) -> &[u8] {
        &self.dev_eui
    }
    pub fn clear_dev_eui(&mut self) {
        self.dev_eui.clear();
    }

    // Param is passed by value, moved
    pub fn set_dev_eui(&mut self, v: ::std::vec::Vec<u8>) {
        self.dev_eui = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dev_eui(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.dev_eui
    }

    // Take field
    pub fn take_dev_eui(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.dev_eui, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DeviceIdentifier {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.app_eui)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.dev_eui)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.app_eui.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.app_eui);
        }
        if !self.dev_eui.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.dev_eui);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.app_eui.is_empty() {
            os.write_bytes(1, &self.app_eui)?;
        }
        if !self.dev_eui.is_empty() {
            os.write_bytes(2, &self.dev_eui)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeviceIdentifier {
        DeviceIdentifier::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "app_eui",
                    |m: &DeviceIdentifier| { &m.app_eui },
                    |m: &mut DeviceIdentifier| { &mut m.app_eui },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "dev_eui",
                    |m: &DeviceIdentifier| { &m.dev_eui },
                    |m: &mut DeviceIdentifier| { &mut m.dev_eui },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeviceIdentifier>(
                    "DeviceIdentifier",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeviceIdentifier {
        static mut instance: ::protobuf::lazy::Lazy<DeviceIdentifier> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeviceIdentifier,
        };
        unsafe {
            instance.get(DeviceIdentifier::new)
        }
    }
}

impl ::protobuf::Clear for DeviceIdentifier {
    fn clear(&mut self) {
        self.app_eui.clear();
        self.dev_eui.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceIdentifier {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceIdentifier {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Device {
    // message fields
    pub app_eui: ::std::vec::Vec<u8>,
    pub dev_eui: ::std::vec::Vec<u8>,
    pub app_id: ::std::string::String,
    pub dev_id: ::std::string::String,
    pub dev_addr: ::std::vec::Vec<u8>,
    pub nwk_s_key: ::std::vec::Vec<u8>,
    pub app_s_key: ::std::vec::Vec<u8>,
    pub app_key: ::std::vec::Vec<u8>,
    pub f_cnt_up: u32,
    pub f_cnt_down: u32,
    pub disable_f_cnt_check: bool,
    pub uses32_bit_f_cnt: bool,
    pub activation_constraints: ::std::string::String,
    pub used_dev_nonces: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub used_app_nonces: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub last_seen: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Device {
    fn default() -> &'a Device {
        <Device as ::protobuf::Message>::default_instance()
    }
}

impl Device {
    pub fn new() -> Device {
        ::std::default::Default::default()
    }

    // bytes app_eui = 1;


    pub fn get_app_eui(&self) -> &[u8] {
        &self.app_eui
    }
    pub fn clear_app_eui(&mut self) {
        self.app_eui.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_eui(&mut self, v: ::std::vec::Vec<u8>) {
        self.app_eui = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_eui(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.app_eui
    }

    // Take field
    pub fn take_app_eui(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.app_eui, ::std::vec::Vec::new())
    }

    // bytes dev_eui = 2;


    pub fn get_dev_eui(&self) -> &[u8] {
        &self.dev_eui
    }
    pub fn clear_dev_eui(&mut self) {
        self.dev_eui.clear();
    }

    // Param is passed by value, moved
    pub fn set_dev_eui(&mut self, v: ::std::vec::Vec<u8>) {
        self.dev_eui = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dev_eui(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.dev_eui
    }

    // Take field
    pub fn take_dev_eui(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.dev_eui, ::std::vec::Vec::new())
    }

    // string app_id = 3;


    pub fn get_app_id(&self) -> &str {
        &self.app_id
    }
    pub fn clear_app_id(&mut self) {
        self.app_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: ::std::string::String) {
        self.app_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_id(&mut self) -> &mut ::std::string::String {
        &mut self.app_id
    }

    // Take field
    pub fn take_app_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.app_id, ::std::string::String::new())
    }

    // string dev_id = 4;


    pub fn get_dev_id(&self) -> &str {
        &self.dev_id
    }
    pub fn clear_dev_id(&mut self) {
        self.dev_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_dev_id(&mut self, v: ::std::string::String) {
        self.dev_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dev_id(&mut self) -> &mut ::std::string::String {
        &mut self.dev_id
    }

    // Take field
    pub fn take_dev_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dev_id, ::std::string::String::new())
    }

    // bytes dev_addr = 5;


    pub fn get_dev_addr(&self) -> &[u8] {
        &self.dev_addr
    }
    pub fn clear_dev_addr(&mut self) {
        self.dev_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_dev_addr(&mut self, v: ::std::vec::Vec<u8>) {
        self.dev_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dev_addr(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.dev_addr
    }

    // Take field
    pub fn take_dev_addr(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.dev_addr, ::std::vec::Vec::new())
    }

    // bytes nwk_s_key = 6;


    pub fn get_nwk_s_key(&self) -> &[u8] {
        &self.nwk_s_key
    }
    pub fn clear_nwk_s_key(&mut self) {
        self.nwk_s_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_nwk_s_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.nwk_s_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nwk_s_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.nwk_s_key
    }

    // Take field
    pub fn take_nwk_s_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.nwk_s_key, ::std::vec::Vec::new())
    }

    // bytes app_s_key = 7;


    pub fn get_app_s_key(&self) -> &[u8] {
        &self.app_s_key
    }
    pub fn clear_app_s_key(&mut self) {
        self.app_s_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_s_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.app_s_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_s_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.app_s_key
    }

    // Take field
    pub fn take_app_s_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.app_s_key, ::std::vec::Vec::new())
    }

    // bytes app_key = 8;


    pub fn get_app_key(&self) -> &[u8] {
        &self.app_key
    }
    pub fn clear_app_key(&mut self) {
        self.app_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.app_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.app_key
    }

    // Take field
    pub fn take_app_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.app_key, ::std::vec::Vec::new())
    }

    // uint32 f_cnt_up = 9;


    pub fn get_f_cnt_up(&self) -> u32 {
        self.f_cnt_up
    }
    pub fn clear_f_cnt_up(&mut self) {
        self.f_cnt_up = 0;
    }

    // Param is passed by value, moved
    pub fn set_f_cnt_up(&mut self, v: u32) {
        self.f_cnt_up = v;
    }

    // uint32 f_cnt_down = 10;


    pub fn get_f_cnt_down(&self) -> u32 {
        self.f_cnt_down
    }
    pub fn clear_f_cnt_down(&mut self) {
        self.f_cnt_down = 0;
    }

    // Param is passed by value, moved
    pub fn set_f_cnt_down(&mut self, v: u32) {
        self.f_cnt_down = v;
    }

    // bool disable_f_cnt_check = 11;


    pub fn get_disable_f_cnt_check(&self) -> bool {
        self.disable_f_cnt_check
    }
    pub fn clear_disable_f_cnt_check(&mut self) {
        self.disable_f_cnt_check = false;
    }

    // Param is passed by value, moved
    pub fn set_disable_f_cnt_check(&mut self, v: bool) {
        self.disable_f_cnt_check = v;
    }

    // bool uses32_bit_f_cnt = 12;


    pub fn get_uses32_bit_f_cnt(&self) -> bool {
        self.uses32_bit_f_cnt
    }
    pub fn clear_uses32_bit_f_cnt(&mut self) {
        self.uses32_bit_f_cnt = false;
    }

    // Param is passed by value, moved
    pub fn set_uses32_bit_f_cnt(&mut self, v: bool) {
        self.uses32_bit_f_cnt = v;
    }

    // string activation_constraints = 13;


    pub fn get_activation_constraints(&self) -> &str {
        &self.activation_constraints
    }
    pub fn clear_activation_constraints(&mut self) {
        self.activation_constraints.clear();
    }

    // Param is passed by value, moved
    pub fn set_activation_constraints(&mut self, v: ::std::string::String) {
        self.activation_constraints = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_activation_constraints(&mut self) -> &mut ::std::string::String {
        &mut self.activation_constraints
    }

    // Take field
    pub fn take_activation_constraints(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.activation_constraints, ::std::string::String::new())
    }

    // repeated bytes used_dev_nonces = 14;


    pub fn get_used_dev_nonces(&self) -> &[::std::vec::Vec<u8>] {
        &self.used_dev_nonces
    }
    pub fn clear_used_dev_nonces(&mut self) {
        self.used_dev_nonces.clear();
    }

    // Param is passed by value, moved
    pub fn set_used_dev_nonces(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.used_dev_nonces = v;
    }

    // Mutable pointer to the field.
    pub fn mut_used_dev_nonces(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.used_dev_nonces
    }

    // Take field
    pub fn take_used_dev_nonces(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.used_dev_nonces, ::protobuf::RepeatedField::new())
    }

    // repeated bytes used_app_nonces = 15;


    pub fn get_used_app_nonces(&self) -> &[::std::vec::Vec<u8>] {
        &self.used_app_nonces
    }
    pub fn clear_used_app_nonces(&mut self) {
        self.used_app_nonces.clear();
    }

    // Param is passed by value, moved
    pub fn set_used_app_nonces(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.used_app_nonces = v;
    }

    // Mutable pointer to the field.
    pub fn mut_used_app_nonces(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.used_app_nonces
    }

    // Take field
    pub fn take_used_app_nonces(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.used_app_nonces, ::protobuf::RepeatedField::new())
    }

    // int64 last_seen = 21;


    pub fn get_last_seen(&self) -> i64 {
        self.last_seen
    }
    pub fn clear_last_seen(&mut self) {
        self.last_seen = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_seen(&mut self, v: i64) {
        self.last_seen = v;
    }
}

impl ::protobuf::Message for Device {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.app_eui)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.dev_eui)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.app_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dev_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.dev_addr)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.nwk_s_key)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.app_s_key)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.app_key)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.f_cnt_up = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.f_cnt_down = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disable_f_cnt_check = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.uses32_bit_f_cnt = tmp;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.activation_constraints)?;
                },
                14 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.used_dev_nonces)?;
                },
                15 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.used_app_nonces)?;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.last_seen = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.app_eui.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.app_eui);
        }
        if !self.dev_eui.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.dev_eui);
        }
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.app_id);
        }
        if !self.dev_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.dev_id);
        }
        if !self.dev_addr.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.dev_addr);
        }
        if !self.nwk_s_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.nwk_s_key);
        }
        if !self.app_s_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.app_s_key);
        }
        if !self.app_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(8, &self.app_key);
        }
        if self.f_cnt_up != 0 {
            my_size += ::protobuf::rt::value_size(9, self.f_cnt_up, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.f_cnt_down != 0 {
            my_size += ::protobuf::rt::value_size(10, self.f_cnt_down, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.disable_f_cnt_check != false {
            my_size += 2;
        }
        if self.uses32_bit_f_cnt != false {
            my_size += 2;
        }
        if !self.activation_constraints.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.activation_constraints);
        }
        for value in &self.used_dev_nonces {
            my_size += ::protobuf::rt::bytes_size(14, &value);
        };
        for value in &self.used_app_nonces {
            my_size += ::protobuf::rt::bytes_size(15, &value);
        };
        if self.last_seen != 0 {
            my_size += ::protobuf::rt::value_size(21, self.last_seen, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.app_eui.is_empty() {
            os.write_bytes(1, &self.app_eui)?;
        }
        if !self.dev_eui.is_empty() {
            os.write_bytes(2, &self.dev_eui)?;
        }
        if !self.app_id.is_empty() {
            os.write_string(3, &self.app_id)?;
        }
        if !self.dev_id.is_empty() {
            os.write_string(4, &self.dev_id)?;
        }
        if !self.dev_addr.is_empty() {
            os.write_bytes(5, &self.dev_addr)?;
        }
        if !self.nwk_s_key.is_empty() {
            os.write_bytes(6, &self.nwk_s_key)?;
        }
        if !self.app_s_key.is_empty() {
            os.write_bytes(7, &self.app_s_key)?;
        }
        if !self.app_key.is_empty() {
            os.write_bytes(8, &self.app_key)?;
        }
        if self.f_cnt_up != 0 {
            os.write_uint32(9, self.f_cnt_up)?;
        }
        if self.f_cnt_down != 0 {
            os.write_uint32(10, self.f_cnt_down)?;
        }
        if self.disable_f_cnt_check != false {
            os.write_bool(11, self.disable_f_cnt_check)?;
        }
        if self.uses32_bit_f_cnt != false {
            os.write_bool(12, self.uses32_bit_f_cnt)?;
        }
        if !self.activation_constraints.is_empty() {
            os.write_string(13, &self.activation_constraints)?;
        }
        for v in &self.used_dev_nonces {
            os.write_bytes(14, &v)?;
        };
        for v in &self.used_app_nonces {
            os.write_bytes(15, &v)?;
        };
        if self.last_seen != 0 {
            os.write_int64(21, self.last_seen)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Device {
        Device::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "app_eui",
                    |m: &Device| { &m.app_eui },
                    |m: &mut Device| { &mut m.app_eui },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "dev_eui",
                    |m: &Device| { &m.dev_eui },
                    |m: &mut Device| { &mut m.dev_eui },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "app_id",
                    |m: &Device| { &m.app_id },
                    |m: &mut Device| { &mut m.app_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dev_id",
                    |m: &Device| { &m.dev_id },
                    |m: &mut Device| { &mut m.dev_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "dev_addr",
                    |m: &Device| { &m.dev_addr },
                    |m: &mut Device| { &mut m.dev_addr },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "nwk_s_key",
                    |m: &Device| { &m.nwk_s_key },
                    |m: &mut Device| { &mut m.nwk_s_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "app_s_key",
                    |m: &Device| { &m.app_s_key },
                    |m: &mut Device| { &mut m.app_s_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "app_key",
                    |m: &Device| { &m.app_key },
                    |m: &mut Device| { &mut m.app_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "f_cnt_up",
                    |m: &Device| { &m.f_cnt_up },
                    |m: &mut Device| { &mut m.f_cnt_up },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "f_cnt_down",
                    |m: &Device| { &m.f_cnt_down },
                    |m: &mut Device| { &mut m.f_cnt_down },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "disable_f_cnt_check",
                    |m: &Device| { &m.disable_f_cnt_check },
                    |m: &mut Device| { &mut m.disable_f_cnt_check },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "uses32_bit_f_cnt",
                    |m: &Device| { &m.uses32_bit_f_cnt },
                    |m: &mut Device| { &mut m.uses32_bit_f_cnt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "activation_constraints",
                    |m: &Device| { &m.activation_constraints },
                    |m: &mut Device| { &mut m.activation_constraints },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "used_dev_nonces",
                    |m: &Device| { &m.used_dev_nonces },
                    |m: &mut Device| { &mut m.used_dev_nonces },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "used_app_nonces",
                    |m: &Device| { &m.used_app_nonces },
                    |m: &mut Device| { &mut m.used_app_nonces },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "last_seen",
                    |m: &Device| { &m.last_seen },
                    |m: &mut Device| { &mut m.last_seen },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Device>(
                    "Device",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Device {
        static mut instance: ::protobuf::lazy::Lazy<Device> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Device,
        };
        unsafe {
            instance.get(Device::new)
        }
    }
}

impl ::protobuf::Clear for Device {
    fn clear(&mut self) {
        self.app_eui.clear();
        self.dev_eui.clear();
        self.app_id.clear();
        self.dev_id.clear();
        self.dev_addr.clear();
        self.nwk_s_key.clear();
        self.app_s_key.clear();
        self.app_key.clear();
        self.f_cnt_up = 0;
        self.f_cnt_down = 0;
        self.disable_f_cnt_check = false;
        self.uses32_bit_f_cnt = false;
        self.activation_constraints.clear();
        self.used_dev_nonces.clear();
        self.used_app_nonces.clear();
        self.last_seen = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Device {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Device {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n=github.com/TheThingsNetwork/api/protocol/lorawan/device.proto\x12\x07\
    lorawan\x1a\x1bgoogle/protobuf/empty.proto\x1a-github.com/gogo/protobuf/\
    gogoproto/gogo.proto\"\xce\x01\n\x10DeviceIdentifier\x12\\\n\x07app_eui\
    \x18\x01\x20\x01(\x0cR\x06appEuiBC\xe2\xde\x1f\x06AppEUI\xda\xde\x1f1git\
    hub.com/TheThingsNetwork/ttn/core/types.AppEUI\xc8\xde\x1f\0\x12\\\n\x07\
    dev_eui\x18\x02\x20\x01(\x0cR\x06devEuiBC\xc8\xde\x1f\0\xe2\xde\x1f\x06D\
    evEUI\xda\xde\x1f1github.com/TheThingsNetwork/ttn/core/types.DevEUI\"\
    \xf9\x07\n\x06Device\x12\\\n\x07app_eui\x18\x01\x20\x01(\x0cR\x06appEuiB\
    C\xda\xde\x1f1github.com/TheThingsNetwork/ttn/core/types.AppEUI\xe2\xde\
    \x1f\x06AppEUI\xc8\xde\x1f\0\x12\\\n\x07dev_eui\x18\x02\x20\x01(\x0cR\
    \x06devEuiBC\xc8\xde\x1f\0\xda\xde\x1f1github.com/TheThingsNetwork/ttn/c\
    ore/types.DevEUI\xe2\xde\x1f\x06DevEUI\x12\x20\n\x06app_id\x18\x03\x20\
    \x01(\tR\x05appIdB\t\xe2\xde\x1f\x05AppID\x12\x20\n\x06dev_id\x18\x04\
    \x20\x01(\tR\x05devIdB\t\xe2\xde\x1f\x05DevID\x12Q\n\x08dev_addr\x18\x05\
    \x20\x01(\x0cR\x07devAddrB6\xda\xde\x1f2github.com/TheThingsNetwork/ttn/\
    core/types.DevAddr\x12R\n\tnwk_s_key\x18\x06\x20\x01(\x0cR\x07nwkSKeyB6\
    \xda\xde\x1f2github.com/TheThingsNetwork/ttn/core/types.NwkSKey\x12R\n\t\
    app_s_key\x18\x07\x20\x01(\x0cR\x07appSKeyB6\xda\xde\x1f2github.com/TheT\
    hingsNetwork/ttn/core/types.AppSKey\x12N\n\x07app_key\x18\x08\x20\x01(\
    \x0cR\x06appKeyB5\xda\xde\x1f1github.com/TheThingsNetwork/ttn/core/types\
    .AppKey\x12\x18\n\x08f_cnt_up\x18\t\x20\x01(\rR\x06fCntUp\x12\x1c\n\nf_c\
    nt_down\x18\n\x20\x01(\rR\x08fCntDown\x12-\n\x13disable_f_cnt_check\x18\
    \x0b\x20\x01(\x08R\x10disableFCntCheck\x12'\n\x10uses32_bit_f_cnt\x18\
    \x0c\x20\x01(\x08R\ruses32BitFCnt\x125\n\x16activation_constraints\x18\r\
    \x20\x01(\tR\x15activationConstraints\x12_\n\x0fused_dev_nonces\x18\x0e\
    \x20\x03(\x0cR\rusedDevNoncesB7\xda\xde\x1f3github.com/TheThingsNetwork/\
    ttn/core/types.DevNonce\x12_\n\x0fused_app_nonces\x18\x0f\x20\x03(\x0cR\
    \rusedAppNoncesB7\xda\xde\x1f3github.com/TheThingsNetwork/ttn/core/types\
    .AppNonce\x12\x1b\n\tlast_seen\x18\x15\x20\x01(\x03R\x08lastSeen2\xc1\
    \x01\n\rDeviceManager\x127\n\tGetDevice\x12\x19.lorawan.DeviceIdentifier\
    \x1a\x0f.lorawan.Device\x124\n\tSetDevice\x12\x0f.lorawan.Device\x1a\x16\
    .google.protobuf.Empty\x12A\n\x0cDeleteDevice\x12\x19.lorawan.DeviceIden\
    tifier\x1a\x16.google.protobuf.EmptyB\x9a\x01\n)org.thethingsnetwork.api\
    .protocol.lorawanB\x12LoRaWANDeviceProtoP\x01Z0github.com/TheThingsNetwo\
    rk/api/protocol/lorawan\xaa\x02$TheThingsNetwork.API.LoRaWANProtocolb\
    \x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
