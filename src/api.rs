// This file is generated by rust-protobuf 2.6.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct Percentiles {
    // message fields
    pub percentile1: f32,
    pub percentile5: f32,
    pub percentile10: f32,
    pub percentile25: f32,
    pub percentile50: f32,
    pub percentile75: f32,
    pub percentile90: f32,
    pub percentile95: f32,
    pub percentile99: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Percentiles {
    fn default() -> &'a Percentiles {
        <Percentiles as ::protobuf::Message>::default_instance()
    }
}

impl Percentiles {
    pub fn new() -> Percentiles {
        ::std::default::Default::default()
    }

    // float percentile1 = 1;


    pub fn get_percentile1(&self) -> f32 {
        self.percentile1
    }
    pub fn clear_percentile1(&mut self) {
        self.percentile1 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_percentile1(&mut self, v: f32) {
        self.percentile1 = v;
    }

    // float percentile5 = 2;


    pub fn get_percentile5(&self) -> f32 {
        self.percentile5
    }
    pub fn clear_percentile5(&mut self) {
        self.percentile5 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_percentile5(&mut self, v: f32) {
        self.percentile5 = v;
    }

    // float percentile10 = 3;


    pub fn get_percentile10(&self) -> f32 {
        self.percentile10
    }
    pub fn clear_percentile10(&mut self) {
        self.percentile10 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_percentile10(&mut self, v: f32) {
        self.percentile10 = v;
    }

    // float percentile25 = 4;


    pub fn get_percentile25(&self) -> f32 {
        self.percentile25
    }
    pub fn clear_percentile25(&mut self) {
        self.percentile25 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_percentile25(&mut self, v: f32) {
        self.percentile25 = v;
    }

    // float percentile50 = 5;


    pub fn get_percentile50(&self) -> f32 {
        self.percentile50
    }
    pub fn clear_percentile50(&mut self) {
        self.percentile50 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_percentile50(&mut self, v: f32) {
        self.percentile50 = v;
    }

    // float percentile75 = 6;


    pub fn get_percentile75(&self) -> f32 {
        self.percentile75
    }
    pub fn clear_percentile75(&mut self) {
        self.percentile75 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_percentile75(&mut self, v: f32) {
        self.percentile75 = v;
    }

    // float percentile90 = 7;


    pub fn get_percentile90(&self) -> f32 {
        self.percentile90
    }
    pub fn clear_percentile90(&mut self) {
        self.percentile90 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_percentile90(&mut self, v: f32) {
        self.percentile90 = v;
    }

    // float percentile95 = 8;


    pub fn get_percentile95(&self) -> f32 {
        self.percentile95
    }
    pub fn clear_percentile95(&mut self) {
        self.percentile95 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_percentile95(&mut self, v: f32) {
        self.percentile95 = v;
    }

    // float percentile99 = 9;


    pub fn get_percentile99(&self) -> f32 {
        self.percentile99
    }
    pub fn clear_percentile99(&mut self) {
        self.percentile99 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_percentile99(&mut self, v: f32) {
        self.percentile99 = v;
    }
}

impl ::protobuf::Message for Percentiles {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.percentile1 = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.percentile5 = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.percentile10 = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.percentile25 = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.percentile50 = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.percentile75 = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.percentile90 = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.percentile95 = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.percentile99 = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.percentile1 != 0. {
            my_size += 5;
        }
        if self.percentile5 != 0. {
            my_size += 5;
        }
        if self.percentile10 != 0. {
            my_size += 5;
        }
        if self.percentile25 != 0. {
            my_size += 5;
        }
        if self.percentile50 != 0. {
            my_size += 5;
        }
        if self.percentile75 != 0. {
            my_size += 5;
        }
        if self.percentile90 != 0. {
            my_size += 5;
        }
        if self.percentile95 != 0. {
            my_size += 5;
        }
        if self.percentile99 != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.percentile1 != 0. {
            os.write_float(1, self.percentile1)?;
        }
        if self.percentile5 != 0. {
            os.write_float(2, self.percentile5)?;
        }
        if self.percentile10 != 0. {
            os.write_float(3, self.percentile10)?;
        }
        if self.percentile25 != 0. {
            os.write_float(4, self.percentile25)?;
        }
        if self.percentile50 != 0. {
            os.write_float(5, self.percentile50)?;
        }
        if self.percentile75 != 0. {
            os.write_float(6, self.percentile75)?;
        }
        if self.percentile90 != 0. {
            os.write_float(7, self.percentile90)?;
        }
        if self.percentile95 != 0. {
            os.write_float(8, self.percentile95)?;
        }
        if self.percentile99 != 0. {
            os.write_float(9, self.percentile99)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Percentiles {
        Percentiles::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "percentile1",
                    |m: &Percentiles| { &m.percentile1 },
                    |m: &mut Percentiles| { &mut m.percentile1 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "percentile5",
                    |m: &Percentiles| { &m.percentile5 },
                    |m: &mut Percentiles| { &mut m.percentile5 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "percentile10",
                    |m: &Percentiles| { &m.percentile10 },
                    |m: &mut Percentiles| { &mut m.percentile10 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "percentile25",
                    |m: &Percentiles| { &m.percentile25 },
                    |m: &mut Percentiles| { &mut m.percentile25 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "percentile50",
                    |m: &Percentiles| { &m.percentile50 },
                    |m: &mut Percentiles| { &mut m.percentile50 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "percentile75",
                    |m: &Percentiles| { &m.percentile75 },
                    |m: &mut Percentiles| { &mut m.percentile75 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "percentile90",
                    |m: &Percentiles| { &m.percentile90 },
                    |m: &mut Percentiles| { &mut m.percentile90 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "percentile95",
                    |m: &Percentiles| { &m.percentile95 },
                    |m: &mut Percentiles| { &mut m.percentile95 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "percentile99",
                    |m: &Percentiles| { &m.percentile99 },
                    |m: &mut Percentiles| { &mut m.percentile99 },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Percentiles>(
                    "Percentiles",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Percentiles {
        static mut instance: ::protobuf::lazy::Lazy<Percentiles> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Percentiles,
        };
        unsafe {
            instance.get(Percentiles::new)
        }
    }
}

impl ::protobuf::Clear for Percentiles {
    fn clear(&mut self) {
        self.percentile1 = 0.;
        self.percentile5 = 0.;
        self.percentile10 = 0.;
        self.percentile25 = 0.;
        self.percentile50 = 0.;
        self.percentile75 = 0.;
        self.percentile90 = 0.;
        self.percentile95 = 0.;
        self.percentile99 = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Percentiles {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Percentiles {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Rates {
    // message fields
    pub rate1: f32,
    pub rate5: f32,
    pub rate15: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Rates {
    fn default() -> &'a Rates {
        <Rates as ::protobuf::Message>::default_instance()
    }
}

impl Rates {
    pub fn new() -> Rates {
        ::std::default::Default::default()
    }

    // float rate1 = 1;


    pub fn get_rate1(&self) -> f32 {
        self.rate1
    }
    pub fn clear_rate1(&mut self) {
        self.rate1 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_rate1(&mut self, v: f32) {
        self.rate1 = v;
    }

    // float rate5 = 2;


    pub fn get_rate5(&self) -> f32 {
        self.rate5
    }
    pub fn clear_rate5(&mut self) {
        self.rate5 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_rate5(&mut self, v: f32) {
        self.rate5 = v;
    }

    // float rate15 = 3;


    pub fn get_rate15(&self) -> f32 {
        self.rate15
    }
    pub fn clear_rate15(&mut self) {
        self.rate15 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_rate15(&mut self, v: f32) {
        self.rate15 = v;
    }
}

impl ::protobuf::Message for Rates {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.rate1 = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.rate5 = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.rate15 = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.rate1 != 0. {
            my_size += 5;
        }
        if self.rate5 != 0. {
            my_size += 5;
        }
        if self.rate15 != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.rate1 != 0. {
            os.write_float(1, self.rate1)?;
        }
        if self.rate5 != 0. {
            os.write_float(2, self.rate5)?;
        }
        if self.rate15 != 0. {
            os.write_float(3, self.rate15)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Rates {
        Rates::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "rate1",
                    |m: &Rates| { &m.rate1 },
                    |m: &mut Rates| { &mut m.rate1 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "rate5",
                    |m: &Rates| { &m.rate5 },
                    |m: &mut Rates| { &mut m.rate5 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "rate15",
                    |m: &Rates| { &m.rate15 },
                    |m: &mut Rates| { &mut m.rate15 },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Rates>(
                    "Rates",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Rates {
        static mut instance: ::protobuf::lazy::Lazy<Rates> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Rates,
        };
        unsafe {
            instance.get(Rates::new)
        }
    }
}

impl ::protobuf::Clear for Rates {
    fn clear(&mut self) {
        self.rate1 = 0.;
        self.rate5 = 0.;
        self.rate15 = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Rates {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rates {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SystemStats {
    // message fields
    pub load: ::protobuf::SingularPtrField<SystemStats_Loadstats>,
    pub cpu: ::protobuf::SingularPtrField<SystemStats_CPUStats>,
    pub memory: ::protobuf::SingularPtrField<SystemStats_MemoryStats>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SystemStats {
    fn default() -> &'a SystemStats {
        <SystemStats as ::protobuf::Message>::default_instance()
    }
}

impl SystemStats {
    pub fn new() -> SystemStats {
        ::std::default::Default::default()
    }

    // .api.SystemStats.Loadstats load = 1;


    pub fn get_load(&self) -> &SystemStats_Loadstats {
        self.load.as_ref().unwrap_or_else(|| SystemStats_Loadstats::default_instance())
    }
    pub fn clear_load(&mut self) {
        self.load.clear();
    }

    pub fn has_load(&self) -> bool {
        self.load.is_some()
    }

    // Param is passed by value, moved
    pub fn set_load(&mut self, v: SystemStats_Loadstats) {
        self.load = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_load(&mut self) -> &mut SystemStats_Loadstats {
        if self.load.is_none() {
            self.load.set_default();
        }
        self.load.as_mut().unwrap()
    }

    // Take field
    pub fn take_load(&mut self) -> SystemStats_Loadstats {
        self.load.take().unwrap_or_else(|| SystemStats_Loadstats::new())
    }

    // .api.SystemStats.CPUStats cpu = 2;


    pub fn get_cpu(&self) -> &SystemStats_CPUStats {
        self.cpu.as_ref().unwrap_or_else(|| SystemStats_CPUStats::default_instance())
    }
    pub fn clear_cpu(&mut self) {
        self.cpu.clear();
    }

    pub fn has_cpu(&self) -> bool {
        self.cpu.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu(&mut self, v: SystemStats_CPUStats) {
        self.cpu = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cpu(&mut self) -> &mut SystemStats_CPUStats {
        if self.cpu.is_none() {
            self.cpu.set_default();
        }
        self.cpu.as_mut().unwrap()
    }

    // Take field
    pub fn take_cpu(&mut self) -> SystemStats_CPUStats {
        self.cpu.take().unwrap_or_else(|| SystemStats_CPUStats::new())
    }

    // .api.SystemStats.MemoryStats memory = 3;


    pub fn get_memory(&self) -> &SystemStats_MemoryStats {
        self.memory.as_ref().unwrap_or_else(|| SystemStats_MemoryStats::default_instance())
    }
    pub fn clear_memory(&mut self) {
        self.memory.clear();
    }

    pub fn has_memory(&self) -> bool {
        self.memory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_memory(&mut self, v: SystemStats_MemoryStats) {
        self.memory = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_memory(&mut self) -> &mut SystemStats_MemoryStats {
        if self.memory.is_none() {
            self.memory.set_default();
        }
        self.memory.as_mut().unwrap()
    }

    // Take field
    pub fn take_memory(&mut self) -> SystemStats_MemoryStats {
        self.memory.take().unwrap_or_else(|| SystemStats_MemoryStats::new())
    }
}

impl ::protobuf::Message for SystemStats {
    fn is_initialized(&self) -> bool {
        for v in &self.load {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cpu {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.memory {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.load)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cpu)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.memory)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.load.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cpu.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.memory.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.load.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cpu.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.memory.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SystemStats {
        SystemStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SystemStats_Loadstats>>(
                    "load",
                    |m: &SystemStats| { &m.load },
                    |m: &mut SystemStats| { &mut m.load },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SystemStats_CPUStats>>(
                    "cpu",
                    |m: &SystemStats| { &m.cpu },
                    |m: &mut SystemStats| { &mut m.cpu },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SystemStats_MemoryStats>>(
                    "memory",
                    |m: &SystemStats| { &m.memory },
                    |m: &mut SystemStats| { &mut m.memory },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SystemStats>(
                    "SystemStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SystemStats {
        static mut instance: ::protobuf::lazy::Lazy<SystemStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SystemStats,
        };
        unsafe {
            instance.get(SystemStats::new)
        }
    }
}

impl ::protobuf::Clear for SystemStats {
    fn clear(&mut self) {
        self.load.clear();
        self.cpu.clear();
        self.memory.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SystemStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SystemStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SystemStats_Loadstats {
    // message fields
    pub load1: f32,
    pub load5: f32,
    pub load15: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SystemStats_Loadstats {
    fn default() -> &'a SystemStats_Loadstats {
        <SystemStats_Loadstats as ::protobuf::Message>::default_instance()
    }
}

impl SystemStats_Loadstats {
    pub fn new() -> SystemStats_Loadstats {
        ::std::default::Default::default()
    }

    // float load1 = 1;


    pub fn get_load1(&self) -> f32 {
        self.load1
    }
    pub fn clear_load1(&mut self) {
        self.load1 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_load1(&mut self, v: f32) {
        self.load1 = v;
    }

    // float load5 = 2;


    pub fn get_load5(&self) -> f32 {
        self.load5
    }
    pub fn clear_load5(&mut self) {
        self.load5 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_load5(&mut self, v: f32) {
        self.load5 = v;
    }

    // float load15 = 3;


    pub fn get_load15(&self) -> f32 {
        self.load15
    }
    pub fn clear_load15(&mut self) {
        self.load15 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_load15(&mut self, v: f32) {
        self.load15 = v;
    }
}

impl ::protobuf::Message for SystemStats_Loadstats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.load1 = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.load5 = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.load15 = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.load1 != 0. {
            my_size += 5;
        }
        if self.load5 != 0. {
            my_size += 5;
        }
        if self.load15 != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.load1 != 0. {
            os.write_float(1, self.load1)?;
        }
        if self.load5 != 0. {
            os.write_float(2, self.load5)?;
        }
        if self.load15 != 0. {
            os.write_float(3, self.load15)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SystemStats_Loadstats {
        SystemStats_Loadstats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "load1",
                    |m: &SystemStats_Loadstats| { &m.load1 },
                    |m: &mut SystemStats_Loadstats| { &mut m.load1 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "load5",
                    |m: &SystemStats_Loadstats| { &m.load5 },
                    |m: &mut SystemStats_Loadstats| { &mut m.load5 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "load15",
                    |m: &SystemStats_Loadstats| { &m.load15 },
                    |m: &mut SystemStats_Loadstats| { &mut m.load15 },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SystemStats_Loadstats>(
                    "SystemStats_Loadstats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SystemStats_Loadstats {
        static mut instance: ::protobuf::lazy::Lazy<SystemStats_Loadstats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SystemStats_Loadstats,
        };
        unsafe {
            instance.get(SystemStats_Loadstats::new)
        }
    }
}

impl ::protobuf::Clear for SystemStats_Loadstats {
    fn clear(&mut self) {
        self.load1 = 0.;
        self.load5 = 0.;
        self.load15 = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SystemStats_Loadstats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SystemStats_Loadstats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SystemStats_CPUStats {
    // message fields
    pub user: f32,
    pub system: f32,
    pub idle: f32,
    pub percentage: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SystemStats_CPUStats {
    fn default() -> &'a SystemStats_CPUStats {
        <SystemStats_CPUStats as ::protobuf::Message>::default_instance()
    }
}

impl SystemStats_CPUStats {
    pub fn new() -> SystemStats_CPUStats {
        ::std::default::Default::default()
    }

    // float user = 1;


    pub fn get_user(&self) -> f32 {
        self.user
    }
    pub fn clear_user(&mut self) {
        self.user = 0.;
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: f32) {
        self.user = v;
    }

    // float system = 2;


    pub fn get_system(&self) -> f32 {
        self.system
    }
    pub fn clear_system(&mut self) {
        self.system = 0.;
    }

    // Param is passed by value, moved
    pub fn set_system(&mut self, v: f32) {
        self.system = v;
    }

    // float idle = 3;


    pub fn get_idle(&self) -> f32 {
        self.idle
    }
    pub fn clear_idle(&mut self) {
        self.idle = 0.;
    }

    // Param is passed by value, moved
    pub fn set_idle(&mut self, v: f32) {
        self.idle = v;
    }

    // float percentage = 4;


    pub fn get_percentage(&self) -> f32 {
        self.percentage
    }
    pub fn clear_percentage(&mut self) {
        self.percentage = 0.;
    }

    // Param is passed by value, moved
    pub fn set_percentage(&mut self, v: f32) {
        self.percentage = v;
    }
}

impl ::protobuf::Message for SystemStats_CPUStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.user = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.system = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.idle = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.percentage = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.user != 0. {
            my_size += 5;
        }
        if self.system != 0. {
            my_size += 5;
        }
        if self.idle != 0. {
            my_size += 5;
        }
        if self.percentage != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.user != 0. {
            os.write_float(1, self.user)?;
        }
        if self.system != 0. {
            os.write_float(2, self.system)?;
        }
        if self.idle != 0. {
            os.write_float(3, self.idle)?;
        }
        if self.percentage != 0. {
            os.write_float(4, self.percentage)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SystemStats_CPUStats {
        SystemStats_CPUStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "user",
                    |m: &SystemStats_CPUStats| { &m.user },
                    |m: &mut SystemStats_CPUStats| { &mut m.user },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "system",
                    |m: &SystemStats_CPUStats| { &m.system },
                    |m: &mut SystemStats_CPUStats| { &mut m.system },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "idle",
                    |m: &SystemStats_CPUStats| { &m.idle },
                    |m: &mut SystemStats_CPUStats| { &mut m.idle },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "percentage",
                    |m: &SystemStats_CPUStats| { &m.percentage },
                    |m: &mut SystemStats_CPUStats| { &mut m.percentage },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SystemStats_CPUStats>(
                    "SystemStats_CPUStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SystemStats_CPUStats {
        static mut instance: ::protobuf::lazy::Lazy<SystemStats_CPUStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SystemStats_CPUStats,
        };
        unsafe {
            instance.get(SystemStats_CPUStats::new)
        }
    }
}

impl ::protobuf::Clear for SystemStats_CPUStats {
    fn clear(&mut self) {
        self.user = 0.;
        self.system = 0.;
        self.idle = 0.;
        self.percentage = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SystemStats_CPUStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SystemStats_CPUStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SystemStats_MemoryStats {
    // message fields
    pub total: u64,
    pub available: u64,
    pub used: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SystemStats_MemoryStats {
    fn default() -> &'a SystemStats_MemoryStats {
        <SystemStats_MemoryStats as ::protobuf::Message>::default_instance()
    }
}

impl SystemStats_MemoryStats {
    pub fn new() -> SystemStats_MemoryStats {
        ::std::default::Default::default()
    }

    // uint64 total = 1;


    pub fn get_total(&self) -> u64 {
        self.total
    }
    pub fn clear_total(&mut self) {
        self.total = 0;
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: u64) {
        self.total = v;
    }

    // uint64 available = 2;


    pub fn get_available(&self) -> u64 {
        self.available
    }
    pub fn clear_available(&mut self) {
        self.available = 0;
    }

    // Param is passed by value, moved
    pub fn set_available(&mut self, v: u64) {
        self.available = v;
    }

    // uint64 used = 3;


    pub fn get_used(&self) -> u64 {
        self.used
    }
    pub fn clear_used(&mut self) {
        self.used = 0;
    }

    // Param is passed by value, moved
    pub fn set_used(&mut self, v: u64) {
        self.used = v;
    }
}

impl ::protobuf::Message for SystemStats_MemoryStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.total = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.available = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.used = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.total != 0 {
            my_size += ::protobuf::rt::value_size(1, self.total, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.available != 0 {
            my_size += ::protobuf::rt::value_size(2, self.available, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.used != 0 {
            my_size += ::protobuf::rt::value_size(3, self.used, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.total != 0 {
            os.write_uint64(1, self.total)?;
        }
        if self.available != 0 {
            os.write_uint64(2, self.available)?;
        }
        if self.used != 0 {
            os.write_uint64(3, self.used)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SystemStats_MemoryStats {
        SystemStats_MemoryStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "total",
                    |m: &SystemStats_MemoryStats| { &m.total },
                    |m: &mut SystemStats_MemoryStats| { &mut m.total },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "available",
                    |m: &SystemStats_MemoryStats| { &m.available },
                    |m: &mut SystemStats_MemoryStats| { &mut m.available },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "used",
                    |m: &SystemStats_MemoryStats| { &m.used },
                    |m: &mut SystemStats_MemoryStats| { &mut m.used },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SystemStats_MemoryStats>(
                    "SystemStats_MemoryStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SystemStats_MemoryStats {
        static mut instance: ::protobuf::lazy::Lazy<SystemStats_MemoryStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SystemStats_MemoryStats,
        };
        unsafe {
            instance.get(SystemStats_MemoryStats::new)
        }
    }
}

impl ::protobuf::Clear for SystemStats_MemoryStats {
    fn clear(&mut self) {
        self.total = 0;
        self.available = 0;
        self.used = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SystemStats_MemoryStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SystemStats_MemoryStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ComponentStats {
    // message fields
    pub uptime: u64,
    pub cpu: ::protobuf::SingularPtrField<ComponentStats_CPUStats>,
    pub memory: ::protobuf::SingularPtrField<ComponentStats_MemoryStats>,
    pub goroutines: u64,
    pub gc_cpu_fraction: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ComponentStats {
    fn default() -> &'a ComponentStats {
        <ComponentStats as ::protobuf::Message>::default_instance()
    }
}

impl ComponentStats {
    pub fn new() -> ComponentStats {
        ::std::default::Default::default()
    }

    // uint64 uptime = 1;


    pub fn get_uptime(&self) -> u64 {
        self.uptime
    }
    pub fn clear_uptime(&mut self) {
        self.uptime = 0;
    }

    // Param is passed by value, moved
    pub fn set_uptime(&mut self, v: u64) {
        self.uptime = v;
    }

    // .api.ComponentStats.CPUStats cpu = 2;


    pub fn get_cpu(&self) -> &ComponentStats_CPUStats {
        self.cpu.as_ref().unwrap_or_else(|| ComponentStats_CPUStats::default_instance())
    }
    pub fn clear_cpu(&mut self) {
        self.cpu.clear();
    }

    pub fn has_cpu(&self) -> bool {
        self.cpu.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu(&mut self, v: ComponentStats_CPUStats) {
        self.cpu = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cpu(&mut self) -> &mut ComponentStats_CPUStats {
        if self.cpu.is_none() {
            self.cpu.set_default();
        }
        self.cpu.as_mut().unwrap()
    }

    // Take field
    pub fn take_cpu(&mut self) -> ComponentStats_CPUStats {
        self.cpu.take().unwrap_or_else(|| ComponentStats_CPUStats::new())
    }

    // .api.ComponentStats.MemoryStats memory = 3;


    pub fn get_memory(&self) -> &ComponentStats_MemoryStats {
        self.memory.as_ref().unwrap_or_else(|| ComponentStats_MemoryStats::default_instance())
    }
    pub fn clear_memory(&mut self) {
        self.memory.clear();
    }

    pub fn has_memory(&self) -> bool {
        self.memory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_memory(&mut self, v: ComponentStats_MemoryStats) {
        self.memory = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_memory(&mut self) -> &mut ComponentStats_MemoryStats {
        if self.memory.is_none() {
            self.memory.set_default();
        }
        self.memory.as_mut().unwrap()
    }

    // Take field
    pub fn take_memory(&mut self) -> ComponentStats_MemoryStats {
        self.memory.take().unwrap_or_else(|| ComponentStats_MemoryStats::new())
    }

    // uint64 goroutines = 4;


    pub fn get_goroutines(&self) -> u64 {
        self.goroutines
    }
    pub fn clear_goroutines(&mut self) {
        self.goroutines = 0;
    }

    // Param is passed by value, moved
    pub fn set_goroutines(&mut self, v: u64) {
        self.goroutines = v;
    }

    // float gc_cpu_fraction = 5;


    pub fn get_gc_cpu_fraction(&self) -> f32 {
        self.gc_cpu_fraction
    }
    pub fn clear_gc_cpu_fraction(&mut self) {
        self.gc_cpu_fraction = 0.;
    }

    // Param is passed by value, moved
    pub fn set_gc_cpu_fraction(&mut self, v: f32) {
        self.gc_cpu_fraction = v;
    }
}

impl ::protobuf::Message for ComponentStats {
    fn is_initialized(&self) -> bool {
        for v in &self.cpu {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.memory {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.uptime = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cpu)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.memory)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.goroutines = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.gc_cpu_fraction = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.uptime != 0 {
            my_size += ::protobuf::rt::value_size(1, self.uptime, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.cpu.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.memory.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.goroutines != 0 {
            my_size += ::protobuf::rt::value_size(4, self.goroutines, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.gc_cpu_fraction != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.uptime != 0 {
            os.write_uint64(1, self.uptime)?;
        }
        if let Some(ref v) = self.cpu.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.memory.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.goroutines != 0 {
            os.write_uint64(4, self.goroutines)?;
        }
        if self.gc_cpu_fraction != 0. {
            os.write_float(5, self.gc_cpu_fraction)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ComponentStats {
        ComponentStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "uptime",
                    |m: &ComponentStats| { &m.uptime },
                    |m: &mut ComponentStats| { &mut m.uptime },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ComponentStats_CPUStats>>(
                    "cpu",
                    |m: &ComponentStats| { &m.cpu },
                    |m: &mut ComponentStats| { &mut m.cpu },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ComponentStats_MemoryStats>>(
                    "memory",
                    |m: &ComponentStats| { &m.memory },
                    |m: &mut ComponentStats| { &mut m.memory },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "goroutines",
                    |m: &ComponentStats| { &m.goroutines },
                    |m: &mut ComponentStats| { &mut m.goroutines },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "gc_cpu_fraction",
                    |m: &ComponentStats| { &m.gc_cpu_fraction },
                    |m: &mut ComponentStats| { &mut m.gc_cpu_fraction },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ComponentStats>(
                    "ComponentStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ComponentStats {
        static mut instance: ::protobuf::lazy::Lazy<ComponentStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ComponentStats,
        };
        unsafe {
            instance.get(ComponentStats::new)
        }
    }
}

impl ::protobuf::Clear for ComponentStats {
    fn clear(&mut self) {
        self.uptime = 0;
        self.cpu.clear();
        self.memory.clear();
        self.goroutines = 0;
        self.gc_cpu_fraction = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ComponentStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComponentStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ComponentStats_CPUStats {
    // message fields
    pub user: f32,
    pub system: f32,
    pub idle: f32,
    pub percentage: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ComponentStats_CPUStats {
    fn default() -> &'a ComponentStats_CPUStats {
        <ComponentStats_CPUStats as ::protobuf::Message>::default_instance()
    }
}

impl ComponentStats_CPUStats {
    pub fn new() -> ComponentStats_CPUStats {
        ::std::default::Default::default()
    }

    // float user = 1;


    pub fn get_user(&self) -> f32 {
        self.user
    }
    pub fn clear_user(&mut self) {
        self.user = 0.;
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: f32) {
        self.user = v;
    }

    // float system = 2;


    pub fn get_system(&self) -> f32 {
        self.system
    }
    pub fn clear_system(&mut self) {
        self.system = 0.;
    }

    // Param is passed by value, moved
    pub fn set_system(&mut self, v: f32) {
        self.system = v;
    }

    // float idle = 3;


    pub fn get_idle(&self) -> f32 {
        self.idle
    }
    pub fn clear_idle(&mut self) {
        self.idle = 0.;
    }

    // Param is passed by value, moved
    pub fn set_idle(&mut self, v: f32) {
        self.idle = v;
    }

    // float percentage = 4;


    pub fn get_percentage(&self) -> f32 {
        self.percentage
    }
    pub fn clear_percentage(&mut self) {
        self.percentage = 0.;
    }

    // Param is passed by value, moved
    pub fn set_percentage(&mut self, v: f32) {
        self.percentage = v;
    }
}

impl ::protobuf::Message for ComponentStats_CPUStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.user = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.system = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.idle = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.percentage = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.user != 0. {
            my_size += 5;
        }
        if self.system != 0. {
            my_size += 5;
        }
        if self.idle != 0. {
            my_size += 5;
        }
        if self.percentage != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.user != 0. {
            os.write_float(1, self.user)?;
        }
        if self.system != 0. {
            os.write_float(2, self.system)?;
        }
        if self.idle != 0. {
            os.write_float(3, self.idle)?;
        }
        if self.percentage != 0. {
            os.write_float(4, self.percentage)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ComponentStats_CPUStats {
        ComponentStats_CPUStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "user",
                    |m: &ComponentStats_CPUStats| { &m.user },
                    |m: &mut ComponentStats_CPUStats| { &mut m.user },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "system",
                    |m: &ComponentStats_CPUStats| { &m.system },
                    |m: &mut ComponentStats_CPUStats| { &mut m.system },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "idle",
                    |m: &ComponentStats_CPUStats| { &m.idle },
                    |m: &mut ComponentStats_CPUStats| { &mut m.idle },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "percentage",
                    |m: &ComponentStats_CPUStats| { &m.percentage },
                    |m: &mut ComponentStats_CPUStats| { &mut m.percentage },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ComponentStats_CPUStats>(
                    "ComponentStats_CPUStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ComponentStats_CPUStats {
        static mut instance: ::protobuf::lazy::Lazy<ComponentStats_CPUStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ComponentStats_CPUStats,
        };
        unsafe {
            instance.get(ComponentStats_CPUStats::new)
        }
    }
}

impl ::protobuf::Clear for ComponentStats_CPUStats {
    fn clear(&mut self) {
        self.user = 0.;
        self.system = 0.;
        self.idle = 0.;
        self.percentage = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ComponentStats_CPUStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComponentStats_CPUStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ComponentStats_MemoryStats {
    // message fields
    pub memory: u64,
    pub swap: u64,
    pub heap: u64,
    pub stack: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ComponentStats_MemoryStats {
    fn default() -> &'a ComponentStats_MemoryStats {
        <ComponentStats_MemoryStats as ::protobuf::Message>::default_instance()
    }
}

impl ComponentStats_MemoryStats {
    pub fn new() -> ComponentStats_MemoryStats {
        ::std::default::Default::default()
    }

    // uint64 memory = 1;


    pub fn get_memory(&self) -> u64 {
        self.memory
    }
    pub fn clear_memory(&mut self) {
        self.memory = 0;
    }

    // Param is passed by value, moved
    pub fn set_memory(&mut self, v: u64) {
        self.memory = v;
    }

    // uint64 swap = 2;


    pub fn get_swap(&self) -> u64 {
        self.swap
    }
    pub fn clear_swap(&mut self) {
        self.swap = 0;
    }

    // Param is passed by value, moved
    pub fn set_swap(&mut self, v: u64) {
        self.swap = v;
    }

    // uint64 heap = 10;


    pub fn get_heap(&self) -> u64 {
        self.heap
    }
    pub fn clear_heap(&mut self) {
        self.heap = 0;
    }

    // Param is passed by value, moved
    pub fn set_heap(&mut self, v: u64) {
        self.heap = v;
    }

    // uint64 stack = 11;


    pub fn get_stack(&self) -> u64 {
        self.stack
    }
    pub fn clear_stack(&mut self) {
        self.stack = 0;
    }

    // Param is passed by value, moved
    pub fn set_stack(&mut self, v: u64) {
        self.stack = v;
    }
}

impl ::protobuf::Message for ComponentStats_MemoryStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.memory = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.swap = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.heap = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.stack = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.memory != 0 {
            my_size += ::protobuf::rt::value_size(1, self.memory, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.swap != 0 {
            my_size += ::protobuf::rt::value_size(2, self.swap, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.heap != 0 {
            my_size += ::protobuf::rt::value_size(10, self.heap, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.stack != 0 {
            my_size += ::protobuf::rt::value_size(11, self.stack, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.memory != 0 {
            os.write_uint64(1, self.memory)?;
        }
        if self.swap != 0 {
            os.write_uint64(2, self.swap)?;
        }
        if self.heap != 0 {
            os.write_uint64(10, self.heap)?;
        }
        if self.stack != 0 {
            os.write_uint64(11, self.stack)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ComponentStats_MemoryStats {
        ComponentStats_MemoryStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "memory",
                    |m: &ComponentStats_MemoryStats| { &m.memory },
                    |m: &mut ComponentStats_MemoryStats| { &mut m.memory },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "swap",
                    |m: &ComponentStats_MemoryStats| { &m.swap },
                    |m: &mut ComponentStats_MemoryStats| { &mut m.swap },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "heap",
                    |m: &ComponentStats_MemoryStats| { &m.heap },
                    |m: &mut ComponentStats_MemoryStats| { &mut m.heap },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "stack",
                    |m: &ComponentStats_MemoryStats| { &m.stack },
                    |m: &mut ComponentStats_MemoryStats| { &mut m.stack },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ComponentStats_MemoryStats>(
                    "ComponentStats_MemoryStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ComponentStats_MemoryStats {
        static mut instance: ::protobuf::lazy::Lazy<ComponentStats_MemoryStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ComponentStats_MemoryStats,
        };
        unsafe {
            instance.get(ComponentStats_MemoryStats::new)
        }
    }
}

impl ::protobuf::Clear for ComponentStats_MemoryStats {
    fn clear(&mut self) {
        self.memory = 0;
        self.swap = 0;
        self.heap = 0;
        self.stack = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ComponentStats_MemoryStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComponentStats_MemoryStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n)github.com/TheThingsNetwork/api/api.proto\x12\x03api\"\xcd\x02\n\x0bP\
    ercentiles\x12\x20\n\x0bpercentile1\x18\x01\x20\x01(\x02R\x0bpercentile1\
    \x12\x20\n\x0bpercentile5\x18\x02\x20\x01(\x02R\x0bpercentile5\x12\"\n\
    \x0cpercentile10\x18\x03\x20\x01(\x02R\x0cpercentile10\x12\"\n\x0cpercen\
    tile25\x18\x04\x20\x01(\x02R\x0cpercentile25\x12\"\n\x0cpercentile50\x18\
    \x05\x20\x01(\x02R\x0cpercentile50\x12\"\n\x0cpercentile75\x18\x06\x20\
    \x01(\x02R\x0cpercentile75\x12\"\n\x0cpercentile90\x18\x07\x20\x01(\x02R\
    \x0cpercentile90\x12\"\n\x0cpercentile95\x18\x08\x20\x01(\x02R\x0cpercen\
    tile95\x12\"\n\x0cpercentile99\x18\t\x20\x01(\x02R\x0cpercentile99\"K\n\
    \x05Rates\x12\x14\n\x05rate1\x18\x01\x20\x01(\x02R\x05rate1\x12\x14\n\
    \x05rate5\x18\x02\x20\x01(\x02R\x05rate5\x12\x16\n\x06rate15\x18\x03\x20\
    \x01(\x02R\x06rate15\"\xb4\x03\n\x0bSystemStats\x12.\n\x04load\x18\x01\
    \x20\x01(\x0b2\x1a.api.SystemStats.LoadstatsR\x04load\x12+\n\x03cpu\x18\
    \x02\x20\x01(\x0b2\x19.api.SystemStats.CPUStatsR\x03cpu\x124\n\x06memory\
    \x18\x03\x20\x01(\x0b2\x1c.api.SystemStats.MemoryStatsR\x06memory\x1aO\n\
    \tLoadstats\x12\x14\n\x05load1\x18\x01\x20\x01(\x02R\x05load1\x12\x14\n\
    \x05load5\x18\x02\x20\x01(\x02R\x05load5\x12\x16\n\x06load15\x18\x03\x20\
    \x01(\x02R\x06load15\x1aj\n\x08CPUStats\x12\x12\n\x04user\x18\x01\x20\
    \x01(\x02R\x04user\x12\x16\n\x06system\x18\x02\x20\x01(\x02R\x06system\
    \x12\x12\n\x04idle\x18\x03\x20\x01(\x02R\x04idle\x12\x1e\n\npercentage\
    \x18\x04\x20\x01(\x02R\npercentage\x1aU\n\x0bMemoryStats\x12\x14\n\x05to\
    tal\x18\x01\x20\x01(\x04R\x05total\x12\x1c\n\tavailable\x18\x02\x20\x01(\
    \x04R\tavailable\x12\x12\n\x04used\x18\x03\x20\x01(\x04R\x04used\"\xaa\
    \x03\n\x0eComponentStats\x12\x16\n\x06uptime\x18\x01\x20\x01(\x04R\x06up\
    time\x12.\n\x03cpu\x18\x02\x20\x01(\x0b2\x1c.api.ComponentStats.CPUStats\
    R\x03cpu\x127\n\x06memory\x18\x03\x20\x01(\x0b2\x1f.api.ComponentStats.M\
    emoryStatsR\x06memory\x12\x1e\n\ngoroutines\x18\x04\x20\x01(\x04R\ngorou\
    tines\x12&\n\x0fgc_cpu_fraction\x18\x05\x20\x01(\x02R\rgcCpuFraction\x1a\
    j\n\x08CPUStats\x12\x12\n\x04user\x18\x01\x20\x01(\x02R\x04user\x12\x16\
    \n\x06system\x18\x02\x20\x01(\x02R\x06system\x12\x12\n\x04idle\x18\x03\
    \x20\x01(\x02R\x04idle\x12\x1e\n\npercentage\x18\x04\x20\x01(\x02R\nperc\
    entage\x1ac\n\x0bMemoryStats\x12\x16\n\x06memory\x18\x01\x20\x01(\x04R\
    \x06memory\x12\x12\n\x04swap\x18\x02\x20\x01(\x04R\x04swap\x12\x12\n\x04\
    heap\x18\n\x20\x01(\x04R\x04heap\x12\x14\n\x05stack\x18\x0b\x20\x01(\x04\
    R\x05stackB^\n\x18org.thethingsnetwork.apiB\x08APIProtoP\x01Z\x1fgithub.\
    com/TheThingsNetwork/api\xaa\x02\x14TheThingsNetwork.APIb\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
