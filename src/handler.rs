// This file is generated by rust-protobuf 2.6.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct DeviceActivationResponse {
    // message fields
    pub payload: ::std::vec::Vec<u8>,
    pub message: ::protobuf::SingularPtrField<super::protocol::Message>,
    pub downlink_option: ::protobuf::SingularPtrField<super::broker::DownlinkOption>,
    pub activation_metadata: ::protobuf::SingularPtrField<super::protocol::ActivationMetadata>,
    pub trace: ::protobuf::SingularPtrField<super::trace::Trace>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeviceActivationResponse {
    fn default() -> &'a DeviceActivationResponse {
        <DeviceActivationResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeviceActivationResponse {
    pub fn new() -> DeviceActivationResponse {
        ::std::default::Default::default()
    }

    // bytes payload = 1;


    pub fn get_payload(&self) -> &[u8] {
        &self.payload
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payload
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payload, ::std::vec::Vec::new())
    }

    // .protocol.Message message = 2;


    pub fn get_message(&self) -> &super::protocol::Message {
        self.message.as_ref().unwrap_or_else(|| super::protocol::Message::default_instance())
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: super::protocol::Message) {
        self.message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut super::protocol::Message {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> super::protocol::Message {
        self.message.take().unwrap_or_else(|| super::protocol::Message::new())
    }

    // .broker.DownlinkOption downlink_option = 11;


    pub fn get_downlink_option(&self) -> &super::broker::DownlinkOption {
        self.downlink_option.as_ref().unwrap_or_else(|| super::broker::DownlinkOption::default_instance())
    }
    pub fn clear_downlink_option(&mut self) {
        self.downlink_option.clear();
    }

    pub fn has_downlink_option(&self) -> bool {
        self.downlink_option.is_some()
    }

    // Param is passed by value, moved
    pub fn set_downlink_option(&mut self, v: super::broker::DownlinkOption) {
        self.downlink_option = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_downlink_option(&mut self) -> &mut super::broker::DownlinkOption {
        if self.downlink_option.is_none() {
            self.downlink_option.set_default();
        }
        self.downlink_option.as_mut().unwrap()
    }

    // Take field
    pub fn take_downlink_option(&mut self) -> super::broker::DownlinkOption {
        self.downlink_option.take().unwrap_or_else(|| super::broker::DownlinkOption::new())
    }

    // .protocol.ActivationMetadata activation_metadata = 23;


    pub fn get_activation_metadata(&self) -> &super::protocol::ActivationMetadata {
        self.activation_metadata.as_ref().unwrap_or_else(|| super::protocol::ActivationMetadata::default_instance())
    }
    pub fn clear_activation_metadata(&mut self) {
        self.activation_metadata.clear();
    }

    pub fn has_activation_metadata(&self) -> bool {
        self.activation_metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_activation_metadata(&mut self, v: super::protocol::ActivationMetadata) {
        self.activation_metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_activation_metadata(&mut self) -> &mut super::protocol::ActivationMetadata {
        if self.activation_metadata.is_none() {
            self.activation_metadata.set_default();
        }
        self.activation_metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_activation_metadata(&mut self) -> super::protocol::ActivationMetadata {
        self.activation_metadata.take().unwrap_or_else(|| super::protocol::ActivationMetadata::new())
    }

    // .trace.Trace trace = 31;


    pub fn get_trace(&self) -> &super::trace::Trace {
        self.trace.as_ref().unwrap_or_else(|| super::trace::Trace::default_instance())
    }
    pub fn clear_trace(&mut self) {
        self.trace.clear();
    }

    pub fn has_trace(&self) -> bool {
        self.trace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trace(&mut self, v: super::trace::Trace) {
        self.trace = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trace(&mut self) -> &mut super::trace::Trace {
        if self.trace.is_none() {
            self.trace.set_default();
        }
        self.trace.as_mut().unwrap()
    }

    // Take field
    pub fn take_trace(&mut self) -> super::trace::Trace {
        self.trace.take().unwrap_or_else(|| super::trace::Trace::new())
    }
}

impl ::protobuf::Message for DeviceActivationResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.message {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.downlink_option {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.activation_metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.trace {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payload)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.downlink_option)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.activation_metadata)?;
                },
                31 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.trace)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.payload);
        }
        if let Some(ref v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.downlink_option.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.activation_metadata.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.trace.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.payload.is_empty() {
            os.write_bytes(1, &self.payload)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.downlink_option.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.activation_metadata.as_ref() {
            os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.trace.as_ref() {
            os.write_tag(31, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeviceActivationResponse {
        DeviceActivationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payload",
                    |m: &DeviceActivationResponse| { &m.payload },
                    |m: &mut DeviceActivationResponse| { &mut m.payload },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::protocol::Message>>(
                    "message",
                    |m: &DeviceActivationResponse| { &m.message },
                    |m: &mut DeviceActivationResponse| { &mut m.message },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::broker::DownlinkOption>>(
                    "downlink_option",
                    |m: &DeviceActivationResponse| { &m.downlink_option },
                    |m: &mut DeviceActivationResponse| { &mut m.downlink_option },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::protocol::ActivationMetadata>>(
                    "activation_metadata",
                    |m: &DeviceActivationResponse| { &m.activation_metadata },
                    |m: &mut DeviceActivationResponse| { &mut m.activation_metadata },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::trace::Trace>>(
                    "trace",
                    |m: &DeviceActivationResponse| { &m.trace },
                    |m: &mut DeviceActivationResponse| { &mut m.trace },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeviceActivationResponse>(
                    "DeviceActivationResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeviceActivationResponse {
        static mut instance: ::protobuf::lazy::Lazy<DeviceActivationResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeviceActivationResponse,
        };
        unsafe {
            instance.get(DeviceActivationResponse::new)
        }
    }
}

impl ::protobuf::Clear for DeviceActivationResponse {
    fn clear(&mut self) {
        self.payload.clear();
        self.message.clear();
        self.downlink_option.clear();
        self.activation_metadata.clear();
        self.trace.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceActivationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceActivationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatusRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatusRequest {
    fn default() -> &'a StatusRequest {
        <StatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl StatusRequest {
    pub fn new() -> StatusRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StatusRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatusRequest {
        StatusRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<StatusRequest>(
                    "StatusRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StatusRequest {
        static mut instance: ::protobuf::lazy::Lazy<StatusRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StatusRequest,
        };
        unsafe {
            instance.get(StatusRequest::new)
        }
    }
}

impl ::protobuf::Clear for StatusRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Status {
    // message fields
    pub system: ::protobuf::SingularPtrField<super::api::SystemStats>,
    pub component: ::protobuf::SingularPtrField<super::api::ComponentStats>,
    pub uplink: ::protobuf::SingularPtrField<super::api::Rates>,
    pub downlink: ::protobuf::SingularPtrField<super::api::Rates>,
    pub activations: ::protobuf::SingularPtrField<super::api::Rates>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Status {
    fn default() -> &'a Status {
        <Status as ::protobuf::Message>::default_instance()
    }
}

impl Status {
    pub fn new() -> Status {
        ::std::default::Default::default()
    }

    // .api.SystemStats system = 1;


    pub fn get_system(&self) -> &super::api::SystemStats {
        self.system.as_ref().unwrap_or_else(|| super::api::SystemStats::default_instance())
    }
    pub fn clear_system(&mut self) {
        self.system.clear();
    }

    pub fn has_system(&self) -> bool {
        self.system.is_some()
    }

    // Param is passed by value, moved
    pub fn set_system(&mut self, v: super::api::SystemStats) {
        self.system = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_system(&mut self) -> &mut super::api::SystemStats {
        if self.system.is_none() {
            self.system.set_default();
        }
        self.system.as_mut().unwrap()
    }

    // Take field
    pub fn take_system(&mut self) -> super::api::SystemStats {
        self.system.take().unwrap_or_else(|| super::api::SystemStats::new())
    }

    // .api.ComponentStats component = 2;


    pub fn get_component(&self) -> &super::api::ComponentStats {
        self.component.as_ref().unwrap_or_else(|| super::api::ComponentStats::default_instance())
    }
    pub fn clear_component(&mut self) {
        self.component.clear();
    }

    pub fn has_component(&self) -> bool {
        self.component.is_some()
    }

    // Param is passed by value, moved
    pub fn set_component(&mut self, v: super::api::ComponentStats) {
        self.component = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_component(&mut self) -> &mut super::api::ComponentStats {
        if self.component.is_none() {
            self.component.set_default();
        }
        self.component.as_mut().unwrap()
    }

    // Take field
    pub fn take_component(&mut self) -> super::api::ComponentStats {
        self.component.take().unwrap_or_else(|| super::api::ComponentStats::new())
    }

    // .api.Rates uplink = 11;


    pub fn get_uplink(&self) -> &super::api::Rates {
        self.uplink.as_ref().unwrap_or_else(|| super::api::Rates::default_instance())
    }
    pub fn clear_uplink(&mut self) {
        self.uplink.clear();
    }

    pub fn has_uplink(&self) -> bool {
        self.uplink.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uplink(&mut self, v: super::api::Rates) {
        self.uplink = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uplink(&mut self) -> &mut super::api::Rates {
        if self.uplink.is_none() {
            self.uplink.set_default();
        }
        self.uplink.as_mut().unwrap()
    }

    // Take field
    pub fn take_uplink(&mut self) -> super::api::Rates {
        self.uplink.take().unwrap_or_else(|| super::api::Rates::new())
    }

    // .api.Rates downlink = 12;


    pub fn get_downlink(&self) -> &super::api::Rates {
        self.downlink.as_ref().unwrap_or_else(|| super::api::Rates::default_instance())
    }
    pub fn clear_downlink(&mut self) {
        self.downlink.clear();
    }

    pub fn has_downlink(&self) -> bool {
        self.downlink.is_some()
    }

    // Param is passed by value, moved
    pub fn set_downlink(&mut self, v: super::api::Rates) {
        self.downlink = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_downlink(&mut self) -> &mut super::api::Rates {
        if self.downlink.is_none() {
            self.downlink.set_default();
        }
        self.downlink.as_mut().unwrap()
    }

    // Take field
    pub fn take_downlink(&mut self) -> super::api::Rates {
        self.downlink.take().unwrap_or_else(|| super::api::Rates::new())
    }

    // .api.Rates activations = 13;


    pub fn get_activations(&self) -> &super::api::Rates {
        self.activations.as_ref().unwrap_or_else(|| super::api::Rates::default_instance())
    }
    pub fn clear_activations(&mut self) {
        self.activations.clear();
    }

    pub fn has_activations(&self) -> bool {
        self.activations.is_some()
    }

    // Param is passed by value, moved
    pub fn set_activations(&mut self, v: super::api::Rates) {
        self.activations = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_activations(&mut self) -> &mut super::api::Rates {
        if self.activations.is_none() {
            self.activations.set_default();
        }
        self.activations.as_mut().unwrap()
    }

    // Take field
    pub fn take_activations(&mut self) -> super::api::Rates {
        self.activations.take().unwrap_or_else(|| super::api::Rates::new())
    }
}

impl ::protobuf::Message for Status {
    fn is_initialized(&self) -> bool {
        for v in &self.system {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.component {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.uplink {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.downlink {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.activations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.system)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.component)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.uplink)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.downlink)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.activations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.system.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.component.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.uplink.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.downlink.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.activations.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.system.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.component.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.uplink.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.downlink.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.activations.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Status {
        Status::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::api::SystemStats>>(
                    "system",
                    |m: &Status| { &m.system },
                    |m: &mut Status| { &mut m.system },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::api::ComponentStats>>(
                    "component",
                    |m: &Status| { &m.component },
                    |m: &mut Status| { &mut m.component },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::api::Rates>>(
                    "uplink",
                    |m: &Status| { &m.uplink },
                    |m: &mut Status| { &mut m.uplink },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::api::Rates>>(
                    "downlink",
                    |m: &Status| { &m.downlink },
                    |m: &mut Status| { &mut m.downlink },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::api::Rates>>(
                    "activations",
                    |m: &Status| { &m.activations },
                    |m: &mut Status| { &mut m.activations },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Status>(
                    "Status",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Status {
        static mut instance: ::protobuf::lazy::Lazy<Status> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Status,
        };
        unsafe {
            instance.get(Status::new)
        }
    }
}

impl ::protobuf::Clear for Status {
    fn clear(&mut self) {
        self.system.clear();
        self.component.clear();
        self.uplink.clear();
        self.downlink.clear();
        self.activations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Status {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Status {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ApplicationIdentifier {
    // message fields
    pub app_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ApplicationIdentifier {
    fn default() -> &'a ApplicationIdentifier {
        <ApplicationIdentifier as ::protobuf::Message>::default_instance()
    }
}

impl ApplicationIdentifier {
    pub fn new() -> ApplicationIdentifier {
        ::std::default::Default::default()
    }

    // string app_id = 1;


    pub fn get_app_id(&self) -> &str {
        &self.app_id
    }
    pub fn clear_app_id(&mut self) {
        self.app_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: ::std::string::String) {
        self.app_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_id(&mut self) -> &mut ::std::string::String {
        &mut self.app_id
    }

    // Take field
    pub fn take_app_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.app_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ApplicationIdentifier {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.app_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.app_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.app_id.is_empty() {
            os.write_string(1, &self.app_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ApplicationIdentifier {
        ApplicationIdentifier::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "app_id",
                    |m: &ApplicationIdentifier| { &m.app_id },
                    |m: &mut ApplicationIdentifier| { &mut m.app_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ApplicationIdentifier>(
                    "ApplicationIdentifier",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ApplicationIdentifier {
        static mut instance: ::protobuf::lazy::Lazy<ApplicationIdentifier> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ApplicationIdentifier,
        };
        unsafe {
            instance.get(ApplicationIdentifier::new)
        }
    }
}

impl ::protobuf::Clear for ApplicationIdentifier {
    fn clear(&mut self) {
        self.app_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ApplicationIdentifier {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ApplicationIdentifier {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Application {
    // message fields
    pub app_id: ::std::string::String,
    pub payload_format: ::std::string::String,
    pub decoder: ::std::string::String,
    pub converter: ::std::string::String,
    pub validator: ::std::string::String,
    pub encoder: ::std::string::String,
    pub register_on_join_access_key: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Application {
    fn default() -> &'a Application {
        <Application as ::protobuf::Message>::default_instance()
    }
}

impl Application {
    pub fn new() -> Application {
        ::std::default::Default::default()
    }

    // string app_id = 1;


    pub fn get_app_id(&self) -> &str {
        &self.app_id
    }
    pub fn clear_app_id(&mut self) {
        self.app_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: ::std::string::String) {
        self.app_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_id(&mut self) -> &mut ::std::string::String {
        &mut self.app_id
    }

    // Take field
    pub fn take_app_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.app_id, ::std::string::String::new())
    }

    // string payload_format = 6;


    pub fn get_payload_format(&self) -> &str {
        &self.payload_format
    }
    pub fn clear_payload_format(&mut self) {
        self.payload_format.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload_format(&mut self, v: ::std::string::String) {
        self.payload_format = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload_format(&mut self) -> &mut ::std::string::String {
        &mut self.payload_format
    }

    // Take field
    pub fn take_payload_format(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payload_format, ::std::string::String::new())
    }

    // string decoder = 2;


    pub fn get_decoder(&self) -> &str {
        &self.decoder
    }
    pub fn clear_decoder(&mut self) {
        self.decoder.clear();
    }

    // Param is passed by value, moved
    pub fn set_decoder(&mut self, v: ::std::string::String) {
        self.decoder = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_decoder(&mut self) -> &mut ::std::string::String {
        &mut self.decoder
    }

    // Take field
    pub fn take_decoder(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.decoder, ::std::string::String::new())
    }

    // string converter = 3;


    pub fn get_converter(&self) -> &str {
        &self.converter
    }
    pub fn clear_converter(&mut self) {
        self.converter.clear();
    }

    // Param is passed by value, moved
    pub fn set_converter(&mut self, v: ::std::string::String) {
        self.converter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_converter(&mut self) -> &mut ::std::string::String {
        &mut self.converter
    }

    // Take field
    pub fn take_converter(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.converter, ::std::string::String::new())
    }

    // string validator = 4;


    pub fn get_validator(&self) -> &str {
        &self.validator
    }
    pub fn clear_validator(&mut self) {
        self.validator.clear();
    }

    // Param is passed by value, moved
    pub fn set_validator(&mut self, v: ::std::string::String) {
        self.validator = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_validator(&mut self) -> &mut ::std::string::String {
        &mut self.validator
    }

    // Take field
    pub fn take_validator(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.validator, ::std::string::String::new())
    }

    // string encoder = 5;


    pub fn get_encoder(&self) -> &str {
        &self.encoder
    }
    pub fn clear_encoder(&mut self) {
        self.encoder.clear();
    }

    // Param is passed by value, moved
    pub fn set_encoder(&mut self, v: ::std::string::String) {
        self.encoder = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encoder(&mut self) -> &mut ::std::string::String {
        &mut self.encoder
    }

    // Take field
    pub fn take_encoder(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.encoder, ::std::string::String::new())
    }

    // string register_on_join_access_key = 7;


    pub fn get_register_on_join_access_key(&self) -> &str {
        &self.register_on_join_access_key
    }
    pub fn clear_register_on_join_access_key(&mut self) {
        self.register_on_join_access_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_register_on_join_access_key(&mut self, v: ::std::string::String) {
        self.register_on_join_access_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_register_on_join_access_key(&mut self) -> &mut ::std::string::String {
        &mut self.register_on_join_access_key
    }

    // Take field
    pub fn take_register_on_join_access_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.register_on_join_access_key, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Application {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.app_id)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payload_format)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.decoder)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.converter)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.validator)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.encoder)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.register_on_join_access_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.app_id);
        }
        if !self.payload_format.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.payload_format);
        }
        if !self.decoder.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.decoder);
        }
        if !self.converter.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.converter);
        }
        if !self.validator.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.validator);
        }
        if !self.encoder.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.encoder);
        }
        if !self.register_on_join_access_key.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.register_on_join_access_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.app_id.is_empty() {
            os.write_string(1, &self.app_id)?;
        }
        if !self.payload_format.is_empty() {
            os.write_string(6, &self.payload_format)?;
        }
        if !self.decoder.is_empty() {
            os.write_string(2, &self.decoder)?;
        }
        if !self.converter.is_empty() {
            os.write_string(3, &self.converter)?;
        }
        if !self.validator.is_empty() {
            os.write_string(4, &self.validator)?;
        }
        if !self.encoder.is_empty() {
            os.write_string(5, &self.encoder)?;
        }
        if !self.register_on_join_access_key.is_empty() {
            os.write_string(7, &self.register_on_join_access_key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Application {
        Application::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "app_id",
                    |m: &Application| { &m.app_id },
                    |m: &mut Application| { &mut m.app_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "payload_format",
                    |m: &Application| { &m.payload_format },
                    |m: &mut Application| { &mut m.payload_format },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "decoder",
                    |m: &Application| { &m.decoder },
                    |m: &mut Application| { &mut m.decoder },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "converter",
                    |m: &Application| { &m.converter },
                    |m: &mut Application| { &mut m.converter },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "validator",
                    |m: &Application| { &m.validator },
                    |m: &mut Application| { &mut m.validator },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "encoder",
                    |m: &Application| { &m.encoder },
                    |m: &mut Application| { &mut m.encoder },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "register_on_join_access_key",
                    |m: &Application| { &m.register_on_join_access_key },
                    |m: &mut Application| { &mut m.register_on_join_access_key },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Application>(
                    "Application",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Application {
        static mut instance: ::protobuf::lazy::Lazy<Application> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Application,
        };
        unsafe {
            instance.get(Application::new)
        }
    }
}

impl ::protobuf::Clear for Application {
    fn clear(&mut self) {
        self.app_id.clear();
        self.payload_format.clear();
        self.decoder.clear();
        self.converter.clear();
        self.validator.clear();
        self.encoder.clear();
        self.register_on_join_access_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Application {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Application {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeviceIdentifier {
    // message fields
    pub app_id: ::std::string::String,
    pub dev_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeviceIdentifier {
    fn default() -> &'a DeviceIdentifier {
        <DeviceIdentifier as ::protobuf::Message>::default_instance()
    }
}

impl DeviceIdentifier {
    pub fn new() -> DeviceIdentifier {
        ::std::default::Default::default()
    }

    // string app_id = 1;


    pub fn get_app_id(&self) -> &str {
        &self.app_id
    }
    pub fn clear_app_id(&mut self) {
        self.app_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: ::std::string::String) {
        self.app_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_id(&mut self) -> &mut ::std::string::String {
        &mut self.app_id
    }

    // Take field
    pub fn take_app_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.app_id, ::std::string::String::new())
    }

    // string dev_id = 2;


    pub fn get_dev_id(&self) -> &str {
        &self.dev_id
    }
    pub fn clear_dev_id(&mut self) {
        self.dev_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_dev_id(&mut self, v: ::std::string::String) {
        self.dev_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dev_id(&mut self) -> &mut ::std::string::String {
        &mut self.dev_id
    }

    // Take field
    pub fn take_dev_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dev_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeviceIdentifier {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dev_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.app_id);
        }
        if !self.dev_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dev_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.app_id.is_empty() {
            os.write_string(1, &self.app_id)?;
        }
        if !self.dev_id.is_empty() {
            os.write_string(2, &self.dev_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeviceIdentifier {
        DeviceIdentifier::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "app_id",
                    |m: &DeviceIdentifier| { &m.app_id },
                    |m: &mut DeviceIdentifier| { &mut m.app_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dev_id",
                    |m: &DeviceIdentifier| { &m.dev_id },
                    |m: &mut DeviceIdentifier| { &mut m.dev_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeviceIdentifier>(
                    "DeviceIdentifier",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeviceIdentifier {
        static mut instance: ::protobuf::lazy::Lazy<DeviceIdentifier> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeviceIdentifier,
        };
        unsafe {
            instance.get(DeviceIdentifier::new)
        }
    }
}

impl ::protobuf::Clear for DeviceIdentifier {
    fn clear(&mut self) {
        self.app_id.clear();
        self.dev_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceIdentifier {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceIdentifier {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Device {
    // message fields
    pub app_id: ::std::string::String,
    pub dev_id: ::std::string::String,
    pub latitude: f32,
    pub longitude: f32,
    pub altitude: i32,
    pub attributes: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub description: ::std::string::String,
    // message oneof groups
    pub device: ::std::option::Option<Device_oneof_device>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Device {
    fn default() -> &'a Device {
        <Device as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Device_oneof_device {
    lorawan_device(super::device::Device),
}

impl Device {
    pub fn new() -> Device {
        ::std::default::Default::default()
    }

    // string app_id = 1;


    pub fn get_app_id(&self) -> &str {
        &self.app_id
    }
    pub fn clear_app_id(&mut self) {
        self.app_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: ::std::string::String) {
        self.app_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_id(&mut self) -> &mut ::std::string::String {
        &mut self.app_id
    }

    // Take field
    pub fn take_app_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.app_id, ::std::string::String::new())
    }

    // string dev_id = 2;


    pub fn get_dev_id(&self) -> &str {
        &self.dev_id
    }
    pub fn clear_dev_id(&mut self) {
        self.dev_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_dev_id(&mut self, v: ::std::string::String) {
        self.dev_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dev_id(&mut self) -> &mut ::std::string::String {
        &mut self.dev_id
    }

    // Take field
    pub fn take_dev_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dev_id, ::std::string::String::new())
    }

    // .lorawan.Device lorawan_device = 3;


    pub fn get_lorawan_device(&self) -> &super::device::Device {
        match self.device {
            ::std::option::Option::Some(Device_oneof_device::lorawan_device(ref v)) => v,
            _ => super::device::Device::default_instance(),
        }
    }
    pub fn clear_lorawan_device(&mut self) {
        self.device = ::std::option::Option::None;
    }

    pub fn has_lorawan_device(&self) -> bool {
        match self.device {
            ::std::option::Option::Some(Device_oneof_device::lorawan_device(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_lorawan_device(&mut self, v: super::device::Device) {
        self.device = ::std::option::Option::Some(Device_oneof_device::lorawan_device(v))
    }

    // Mutable pointer to the field.
    pub fn mut_lorawan_device(&mut self) -> &mut super::device::Device {
        if let ::std::option::Option::Some(Device_oneof_device::lorawan_device(_)) = self.device {
        } else {
            self.device = ::std::option::Option::Some(Device_oneof_device::lorawan_device(super::device::Device::new()));
        }
        match self.device {
            ::std::option::Option::Some(Device_oneof_device::lorawan_device(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_lorawan_device(&mut self) -> super::device::Device {
        if self.has_lorawan_device() {
            match self.device.take() {
                ::std::option::Option::Some(Device_oneof_device::lorawan_device(v)) => v,
                _ => panic!(),
            }
        } else {
            super::device::Device::new()
        }
    }

    // float latitude = 10;


    pub fn get_latitude(&self) -> f32 {
        self.latitude
    }
    pub fn clear_latitude(&mut self) {
        self.latitude = 0.;
    }

    // Param is passed by value, moved
    pub fn set_latitude(&mut self, v: f32) {
        self.latitude = v;
    }

    // float longitude = 11;


    pub fn get_longitude(&self) -> f32 {
        self.longitude
    }
    pub fn clear_longitude(&mut self) {
        self.longitude = 0.;
    }

    // Param is passed by value, moved
    pub fn set_longitude(&mut self, v: f32) {
        self.longitude = v;
    }

    // int32 altitude = 12;


    pub fn get_altitude(&self) -> i32 {
        self.altitude
    }
    pub fn clear_altitude(&mut self) {
        self.altitude = 0;
    }

    // Param is passed by value, moved
    pub fn set_altitude(&mut self, v: i32) {
        self.altitude = v;
    }

    // repeated .handler.Device.AttributesEntry attributes = 13;


    pub fn get_attributes(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.attributes
    }
    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.attributes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attributes(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.attributes
    }

    // Take field
    pub fn take_attributes(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.attributes, ::std::collections::HashMap::new())
    }

    // string description = 20;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Device {
    fn is_initialized(&self) -> bool {
        if let Some(Device_oneof_device::lorawan_device(ref v)) = self.device {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dev_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.device = ::std::option::Option::Some(Device_oneof_device::lorawan_device(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.latitude = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.longitude = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.altitude = tmp;
                },
                13 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.attributes)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.app_id);
        }
        if !self.dev_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dev_id);
        }
        if self.latitude != 0. {
            my_size += 5;
        }
        if self.longitude != 0. {
            my_size += 5;
        }
        if self.altitude != 0 {
            my_size += ::protobuf::rt::value_size(12, self.altitude, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(13, &self.attributes);
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(20, &self.description);
        }
        if let ::std::option::Option::Some(ref v) = self.device {
            match v {
                &Device_oneof_device::lorawan_device(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.app_id.is_empty() {
            os.write_string(1, &self.app_id)?;
        }
        if !self.dev_id.is_empty() {
            os.write_string(2, &self.dev_id)?;
        }
        if self.latitude != 0. {
            os.write_float(10, self.latitude)?;
        }
        if self.longitude != 0. {
            os.write_float(11, self.longitude)?;
        }
        if self.altitude != 0 {
            os.write_int32(12, self.altitude)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(13, &self.attributes, os)?;
        if !self.description.is_empty() {
            os.write_string(20, &self.description)?;
        }
        if let ::std::option::Option::Some(ref v) = self.device {
            match v {
                &Device_oneof_device::lorawan_device(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Device {
        Device::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "app_id",
                    |m: &Device| { &m.app_id },
                    |m: &mut Device| { &mut m.app_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dev_id",
                    |m: &Device| { &m.dev_id },
                    |m: &mut Device| { &mut m.dev_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::device::Device>(
                    "lorawan_device",
                    Device::has_lorawan_device,
                    Device::get_lorawan_device,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "latitude",
                    |m: &Device| { &m.latitude },
                    |m: &mut Device| { &mut m.latitude },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "longitude",
                    |m: &Device| { &m.longitude },
                    |m: &mut Device| { &mut m.longitude },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "altitude",
                    |m: &Device| { &m.altitude },
                    |m: &mut Device| { &mut m.altitude },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "attributes",
                    |m: &Device| { &m.attributes },
                    |m: &mut Device| { &mut m.attributes },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "description",
                    |m: &Device| { &m.description },
                    |m: &mut Device| { &mut m.description },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Device>(
                    "Device",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Device {
        static mut instance: ::protobuf::lazy::Lazy<Device> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Device,
        };
        unsafe {
            instance.get(Device::new)
        }
    }
}

impl ::protobuf::Clear for Device {
    fn clear(&mut self) {
        self.app_id.clear();
        self.dev_id.clear();
        self.device = ::std::option::Option::None;
        self.latitude = 0.;
        self.longitude = 0.;
        self.altitude = 0;
        self.attributes.clear();
        self.description.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Device {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Device {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeviceList {
    // message fields
    pub devices: ::protobuf::RepeatedField<Device>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeviceList {
    fn default() -> &'a DeviceList {
        <DeviceList as ::protobuf::Message>::default_instance()
    }
}

impl DeviceList {
    pub fn new() -> DeviceList {
        ::std::default::Default::default()
    }

    // repeated .handler.Device devices = 1;


    pub fn get_devices(&self) -> &[Device] {
        &self.devices
    }
    pub fn clear_devices(&mut self) {
        self.devices.clear();
    }

    // Param is passed by value, moved
    pub fn set_devices(&mut self, v: ::protobuf::RepeatedField<Device>) {
        self.devices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_devices(&mut self) -> &mut ::protobuf::RepeatedField<Device> {
        &mut self.devices
    }

    // Take field
    pub fn take_devices(&mut self) -> ::protobuf::RepeatedField<Device> {
        ::std::mem::replace(&mut self.devices, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DeviceList {
    fn is_initialized(&self) -> bool {
        for v in &self.devices {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.devices)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.devices {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.devices {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeviceList {
        DeviceList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Device>>(
                    "devices",
                    |m: &DeviceList| { &m.devices },
                    |m: &mut DeviceList| { &mut m.devices },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeviceList>(
                    "DeviceList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeviceList {
        static mut instance: ::protobuf::lazy::Lazy<DeviceList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeviceList,
        };
        unsafe {
            instance.get(DeviceList::new)
        }
    }
}

impl ::protobuf::Clear for DeviceList {
    fn clear(&mut self) {
        self.devices.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DryDownlinkMessage {
    // message fields
    pub payload: ::std::vec::Vec<u8>,
    pub fields: ::std::string::String,
    pub app: ::protobuf::SingularPtrField<Application>,
    pub port: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DryDownlinkMessage {
    fn default() -> &'a DryDownlinkMessage {
        <DryDownlinkMessage as ::protobuf::Message>::default_instance()
    }
}

impl DryDownlinkMessage {
    pub fn new() -> DryDownlinkMessage {
        ::std::default::Default::default()
    }

    // bytes payload = 1;


    pub fn get_payload(&self) -> &[u8] {
        &self.payload
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payload
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payload, ::std::vec::Vec::new())
    }

    // string fields = 2;


    pub fn get_fields(&self) -> &str {
        &self.fields
    }
    pub fn clear_fields(&mut self) {
        self.fields.clear();
    }

    // Param is passed by value, moved
    pub fn set_fields(&mut self, v: ::std::string::String) {
        self.fields = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fields(&mut self) -> &mut ::std::string::String {
        &mut self.fields
    }

    // Take field
    pub fn take_fields(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fields, ::std::string::String::new())
    }

    // .handler.Application app = 3;


    pub fn get_app(&self) -> &Application {
        self.app.as_ref().unwrap_or_else(|| Application::default_instance())
    }
    pub fn clear_app(&mut self) {
        self.app.clear();
    }

    pub fn has_app(&self) -> bool {
        self.app.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app(&mut self, v: Application) {
        self.app = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app(&mut self) -> &mut Application {
        if self.app.is_none() {
            self.app.set_default();
        }
        self.app.as_mut().unwrap()
    }

    // Take field
    pub fn take_app(&mut self) -> Application {
        self.app.take().unwrap_or_else(|| Application::new())
    }

    // uint32 port = 4;


    pub fn get_port(&self) -> u32 {
        self.port
    }
    pub fn clear_port(&mut self) {
        self.port = 0;
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = v;
    }
}

impl ::protobuf::Message for DryDownlinkMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.app {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payload)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fields)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.app)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.payload);
        }
        if !self.fields.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.fields);
        }
        if let Some(ref v) = self.app.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(4, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.payload.is_empty() {
            os.write_bytes(1, &self.payload)?;
        }
        if !self.fields.is_empty() {
            os.write_string(2, &self.fields)?;
        }
        if let Some(ref v) = self.app.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.port != 0 {
            os.write_uint32(4, self.port)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DryDownlinkMessage {
        DryDownlinkMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payload",
                    |m: &DryDownlinkMessage| { &m.payload },
                    |m: &mut DryDownlinkMessage| { &mut m.payload },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fields",
                    |m: &DryDownlinkMessage| { &m.fields },
                    |m: &mut DryDownlinkMessage| { &mut m.fields },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Application>>(
                    "app",
                    |m: &DryDownlinkMessage| { &m.app },
                    |m: &mut DryDownlinkMessage| { &mut m.app },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "port",
                    |m: &DryDownlinkMessage| { &m.port },
                    |m: &mut DryDownlinkMessage| { &mut m.port },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DryDownlinkMessage>(
                    "DryDownlinkMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DryDownlinkMessage {
        static mut instance: ::protobuf::lazy::Lazy<DryDownlinkMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DryDownlinkMessage,
        };
        unsafe {
            instance.get(DryDownlinkMessage::new)
        }
    }
}

impl ::protobuf::Clear for DryDownlinkMessage {
    fn clear(&mut self) {
        self.payload.clear();
        self.fields.clear();
        self.app.clear();
        self.port = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DryDownlinkMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DryDownlinkMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DryUplinkMessage {
    // message fields
    pub payload: ::std::vec::Vec<u8>,
    pub app: ::protobuf::SingularPtrField<Application>,
    pub port: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DryUplinkMessage {
    fn default() -> &'a DryUplinkMessage {
        <DryUplinkMessage as ::protobuf::Message>::default_instance()
    }
}

impl DryUplinkMessage {
    pub fn new() -> DryUplinkMessage {
        ::std::default::Default::default()
    }

    // bytes payload = 1;


    pub fn get_payload(&self) -> &[u8] {
        &self.payload
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payload
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payload, ::std::vec::Vec::new())
    }

    // .handler.Application app = 2;


    pub fn get_app(&self) -> &Application {
        self.app.as_ref().unwrap_or_else(|| Application::default_instance())
    }
    pub fn clear_app(&mut self) {
        self.app.clear();
    }

    pub fn has_app(&self) -> bool {
        self.app.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app(&mut self, v: Application) {
        self.app = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app(&mut self) -> &mut Application {
        if self.app.is_none() {
            self.app.set_default();
        }
        self.app.as_mut().unwrap()
    }

    // Take field
    pub fn take_app(&mut self) -> Application {
        self.app.take().unwrap_or_else(|| Application::new())
    }

    // uint32 port = 3;


    pub fn get_port(&self) -> u32 {
        self.port
    }
    pub fn clear_port(&mut self) {
        self.port = 0;
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = v;
    }
}

impl ::protobuf::Message for DryUplinkMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.app {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payload)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.app)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.payload);
        }
        if let Some(ref v) = self.app.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(3, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.payload.is_empty() {
            os.write_bytes(1, &self.payload)?;
        }
        if let Some(ref v) = self.app.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.port != 0 {
            os.write_uint32(3, self.port)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DryUplinkMessage {
        DryUplinkMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payload",
                    |m: &DryUplinkMessage| { &m.payload },
                    |m: &mut DryUplinkMessage| { &mut m.payload },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Application>>(
                    "app",
                    |m: &DryUplinkMessage| { &m.app },
                    |m: &mut DryUplinkMessage| { &mut m.app },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "port",
                    |m: &DryUplinkMessage| { &m.port },
                    |m: &mut DryUplinkMessage| { &mut m.port },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DryUplinkMessage>(
                    "DryUplinkMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DryUplinkMessage {
        static mut instance: ::protobuf::lazy::Lazy<DryUplinkMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DryUplinkMessage,
        };
        unsafe {
            instance.get(DryUplinkMessage::new)
        }
    }
}

impl ::protobuf::Clear for DryUplinkMessage {
    fn clear(&mut self) {
        self.payload.clear();
        self.app.clear();
        self.port = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DryUplinkMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DryUplinkMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SimulatedUplinkMessage {
    // message fields
    pub app_id: ::std::string::String,
    pub dev_id: ::std::string::String,
    pub payload: ::std::vec::Vec<u8>,
    pub port: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SimulatedUplinkMessage {
    fn default() -> &'a SimulatedUplinkMessage {
        <SimulatedUplinkMessage as ::protobuf::Message>::default_instance()
    }
}

impl SimulatedUplinkMessage {
    pub fn new() -> SimulatedUplinkMessage {
        ::std::default::Default::default()
    }

    // string app_id = 1;


    pub fn get_app_id(&self) -> &str {
        &self.app_id
    }
    pub fn clear_app_id(&mut self) {
        self.app_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: ::std::string::String) {
        self.app_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_id(&mut self) -> &mut ::std::string::String {
        &mut self.app_id
    }

    // Take field
    pub fn take_app_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.app_id, ::std::string::String::new())
    }

    // string dev_id = 2;


    pub fn get_dev_id(&self) -> &str {
        &self.dev_id
    }
    pub fn clear_dev_id(&mut self) {
        self.dev_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_dev_id(&mut self, v: ::std::string::String) {
        self.dev_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dev_id(&mut self) -> &mut ::std::string::String {
        &mut self.dev_id
    }

    // Take field
    pub fn take_dev_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dev_id, ::std::string::String::new())
    }

    // bytes payload = 3;


    pub fn get_payload(&self) -> &[u8] {
        &self.payload
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payload
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payload, ::std::vec::Vec::new())
    }

    // uint32 port = 4;


    pub fn get_port(&self) -> u32 {
        self.port
    }
    pub fn clear_port(&mut self) {
        self.port = 0;
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = v;
    }
}

impl ::protobuf::Message for SimulatedUplinkMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dev_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payload)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.app_id);
        }
        if !self.dev_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dev_id);
        }
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.payload);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(4, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.app_id.is_empty() {
            os.write_string(1, &self.app_id)?;
        }
        if !self.dev_id.is_empty() {
            os.write_string(2, &self.dev_id)?;
        }
        if !self.payload.is_empty() {
            os.write_bytes(3, &self.payload)?;
        }
        if self.port != 0 {
            os.write_uint32(4, self.port)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SimulatedUplinkMessage {
        SimulatedUplinkMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "app_id",
                    |m: &SimulatedUplinkMessage| { &m.app_id },
                    |m: &mut SimulatedUplinkMessage| { &mut m.app_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dev_id",
                    |m: &SimulatedUplinkMessage| { &m.dev_id },
                    |m: &mut SimulatedUplinkMessage| { &mut m.dev_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payload",
                    |m: &SimulatedUplinkMessage| { &m.payload },
                    |m: &mut SimulatedUplinkMessage| { &mut m.payload },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "port",
                    |m: &SimulatedUplinkMessage| { &m.port },
                    |m: &mut SimulatedUplinkMessage| { &mut m.port },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SimulatedUplinkMessage>(
                    "SimulatedUplinkMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SimulatedUplinkMessage {
        static mut instance: ::protobuf::lazy::Lazy<SimulatedUplinkMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SimulatedUplinkMessage,
        };
        unsafe {
            instance.get(SimulatedUplinkMessage::new)
        }
    }
}

impl ::protobuf::Clear for SimulatedUplinkMessage {
    fn clear(&mut self) {
        self.app_id.clear();
        self.dev_id.clear();
        self.payload.clear();
        self.port = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SimulatedUplinkMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SimulatedUplinkMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LogEntry {
    // message fields
    pub function: ::std::string::String,
    pub fields: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LogEntry {
    fn default() -> &'a LogEntry {
        <LogEntry as ::protobuf::Message>::default_instance()
    }
}

impl LogEntry {
    pub fn new() -> LogEntry {
        ::std::default::Default::default()
    }

    // string function = 1;


    pub fn get_function(&self) -> &str {
        &self.function
    }
    pub fn clear_function(&mut self) {
        self.function.clear();
    }

    // Param is passed by value, moved
    pub fn set_function(&mut self, v: ::std::string::String) {
        self.function = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_function(&mut self) -> &mut ::std::string::String {
        &mut self.function
    }

    // Take field
    pub fn take_function(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.function, ::std::string::String::new())
    }

    // repeated string fields = 2;


    pub fn get_fields(&self) -> &[::std::string::String] {
        &self.fields
    }
    pub fn clear_fields(&mut self) {
        self.fields.clear();
    }

    // Param is passed by value, moved
    pub fn set_fields(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.fields = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fields(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.fields
    }

    // Take field
    pub fn take_fields(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.fields, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for LogEntry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.function)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.fields)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.function.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.function);
        }
        for value in &self.fields {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.function.is_empty() {
            os.write_string(1, &self.function)?;
        }
        for v in &self.fields {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LogEntry {
        LogEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "function",
                    |m: &LogEntry| { &m.function },
                    |m: &mut LogEntry| { &mut m.function },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fields",
                    |m: &LogEntry| { &m.fields },
                    |m: &mut LogEntry| { &mut m.fields },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LogEntry>(
                    "LogEntry",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LogEntry {
        static mut instance: ::protobuf::lazy::Lazy<LogEntry> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LogEntry,
        };
        unsafe {
            instance.get(LogEntry::new)
        }
    }
}

impl ::protobuf::Clear for LogEntry {
    fn clear(&mut self) {
        self.function.clear();
        self.fields.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LogEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DryUplinkResult {
    // message fields
    pub payload: ::std::vec::Vec<u8>,
    pub fields: ::std::string::String,
    pub valid: bool,
    pub logs: ::protobuf::RepeatedField<LogEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DryUplinkResult {
    fn default() -> &'a DryUplinkResult {
        <DryUplinkResult as ::protobuf::Message>::default_instance()
    }
}

impl DryUplinkResult {
    pub fn new() -> DryUplinkResult {
        ::std::default::Default::default()
    }

    // bytes payload = 1;


    pub fn get_payload(&self) -> &[u8] {
        &self.payload
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payload
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payload, ::std::vec::Vec::new())
    }

    // string fields = 2;


    pub fn get_fields(&self) -> &str {
        &self.fields
    }
    pub fn clear_fields(&mut self) {
        self.fields.clear();
    }

    // Param is passed by value, moved
    pub fn set_fields(&mut self, v: ::std::string::String) {
        self.fields = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fields(&mut self) -> &mut ::std::string::String {
        &mut self.fields
    }

    // Take field
    pub fn take_fields(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fields, ::std::string::String::new())
    }

    // bool valid = 3;


    pub fn get_valid(&self) -> bool {
        self.valid
    }
    pub fn clear_valid(&mut self) {
        self.valid = false;
    }

    // Param is passed by value, moved
    pub fn set_valid(&mut self, v: bool) {
        self.valid = v;
    }

    // repeated .handler.LogEntry logs = 4;


    pub fn get_logs(&self) -> &[LogEntry] {
        &self.logs
    }
    pub fn clear_logs(&mut self) {
        self.logs.clear();
    }

    // Param is passed by value, moved
    pub fn set_logs(&mut self, v: ::protobuf::RepeatedField<LogEntry>) {
        self.logs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_logs(&mut self) -> &mut ::protobuf::RepeatedField<LogEntry> {
        &mut self.logs
    }

    // Take field
    pub fn take_logs(&mut self) -> ::protobuf::RepeatedField<LogEntry> {
        ::std::mem::replace(&mut self.logs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DryUplinkResult {
    fn is_initialized(&self) -> bool {
        for v in &self.logs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payload)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fields)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.valid = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.logs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.payload);
        }
        if !self.fields.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.fields);
        }
        if self.valid != false {
            my_size += 2;
        }
        for value in &self.logs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.payload.is_empty() {
            os.write_bytes(1, &self.payload)?;
        }
        if !self.fields.is_empty() {
            os.write_string(2, &self.fields)?;
        }
        if self.valid != false {
            os.write_bool(3, self.valid)?;
        }
        for v in &self.logs {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DryUplinkResult {
        DryUplinkResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payload",
                    |m: &DryUplinkResult| { &m.payload },
                    |m: &mut DryUplinkResult| { &mut m.payload },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fields",
                    |m: &DryUplinkResult| { &m.fields },
                    |m: &mut DryUplinkResult| { &mut m.fields },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "valid",
                    |m: &DryUplinkResult| { &m.valid },
                    |m: &mut DryUplinkResult| { &mut m.valid },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LogEntry>>(
                    "logs",
                    |m: &DryUplinkResult| { &m.logs },
                    |m: &mut DryUplinkResult| { &mut m.logs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DryUplinkResult>(
                    "DryUplinkResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DryUplinkResult {
        static mut instance: ::protobuf::lazy::Lazy<DryUplinkResult> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DryUplinkResult,
        };
        unsafe {
            instance.get(DryUplinkResult::new)
        }
    }
}

impl ::protobuf::Clear for DryUplinkResult {
    fn clear(&mut self) {
        self.payload.clear();
        self.fields.clear();
        self.valid = false;
        self.logs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DryUplinkResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DryUplinkResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DryDownlinkResult {
    // message fields
    pub payload: ::std::vec::Vec<u8>,
    pub logs: ::protobuf::RepeatedField<LogEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DryDownlinkResult {
    fn default() -> &'a DryDownlinkResult {
        <DryDownlinkResult as ::protobuf::Message>::default_instance()
    }
}

impl DryDownlinkResult {
    pub fn new() -> DryDownlinkResult {
        ::std::default::Default::default()
    }

    // bytes payload = 1;


    pub fn get_payload(&self) -> &[u8] {
        &self.payload
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payload
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payload, ::std::vec::Vec::new())
    }

    // repeated .handler.LogEntry logs = 2;


    pub fn get_logs(&self) -> &[LogEntry] {
        &self.logs
    }
    pub fn clear_logs(&mut self) {
        self.logs.clear();
    }

    // Param is passed by value, moved
    pub fn set_logs(&mut self, v: ::protobuf::RepeatedField<LogEntry>) {
        self.logs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_logs(&mut self) -> &mut ::protobuf::RepeatedField<LogEntry> {
        &mut self.logs
    }

    // Take field
    pub fn take_logs(&mut self) -> ::protobuf::RepeatedField<LogEntry> {
        ::std::mem::replace(&mut self.logs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DryDownlinkResult {
    fn is_initialized(&self) -> bool {
        for v in &self.logs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payload)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.logs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.payload);
        }
        for value in &self.logs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.payload.is_empty() {
            os.write_bytes(1, &self.payload)?;
        }
        for v in &self.logs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DryDownlinkResult {
        DryDownlinkResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payload",
                    |m: &DryDownlinkResult| { &m.payload },
                    |m: &mut DryDownlinkResult| { &mut m.payload },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LogEntry>>(
                    "logs",
                    |m: &DryDownlinkResult| { &m.logs },
                    |m: &mut DryDownlinkResult| { &mut m.logs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DryDownlinkResult>(
                    "DryDownlinkResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DryDownlinkResult {
        static mut instance: ::protobuf::lazy::Lazy<DryDownlinkResult> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DryDownlinkResult,
        };
        unsafe {
            instance.get(DryDownlinkResult::new)
        }
    }
}

impl ::protobuf::Clear for DryDownlinkResult {
    fn clear(&mut self) {
        self.payload.clear();
        self.logs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DryDownlinkResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DryDownlinkResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n5github.com/TheThingsNetwork/api/handler/handler.proto\x12\x07handler\
    \x1a\x1bgoogle/protobuf/empty.proto\x1a\x1cgoogle/api/annotations.proto\
    \x1a-github.com/gogo/protobuf/gogoproto/gogo.proto\x1a)github.com/TheThi\
    ngsNetwork/api/api.proto\x1a3github.com/TheThingsNetwork/api/broker/brok\
    er.proto\x1a7github.com/TheThingsNetwork/api/protocol/protocol.proto\x1a\
    =github.com/TheThingsNetwork/api/protocol/lorawan/device.proto\x1a1githu\
    b.com/TheThingsNetwork/api/trace/trace.proto\"\xa1\x02\n\x18DeviceActiva\
    tionResponse\x12\x18\n\x07payload\x18\x01\x20\x01(\x0cR\x07payload\x12+\
    \n\x07message\x18\x02\x20\x01(\x0b2\x11.protocol.MessageR\x07message\x12\
    E\n\x0fdownlink_option\x18\x0b\x20\x01(\x0b2\x16.broker.DownlinkOptionR\
    \x0edownlinkOptionB\x04\xc8\xde\x1f\0\x12S\n\x13activation_metadata\x18\
    \x17\x20\x01(\x0b2\x1c.protocol.ActivationMetadataR\x12activationMetadat\
    aB\x04\xc8\xde\x1f\0\x12\"\n\x05trace\x18\x1f\x20\x01(\x0b2\x0c.trace.Tr\
    aceR\x05trace\"\x0f\n\rStatusRequest\"\xeb\x01\n\x06Status\x12.\n\x06sys\
    tem\x18\x01\x20\x01(\x0b2\x10.api.SystemStatsR\x06systemB\x04\xc8\xde\
    \x1f\0\x127\n\tcomponent\x18\x02\x20\x01(\x0b2\x13.api.ComponentStatsR\t\
    componentB\x04\xc8\xde\x1f\0\x12\"\n\x06uplink\x18\x0b\x20\x01(\x0b2\n.a\
    pi.RatesR\x06uplink\x12&\n\x08downlink\x18\x0c\x20\x01(\x0b2\n.api.Rates\
    R\x08downlink\x12,\n\x0bactivations\x18\r\x20\x01(\x0b2\n.api.RatesR\x0b\
    activations\"9\n\x15ApplicationIdentifier\x12\x20\n\x06app_id\x18\x01\
    \x20\x01(\tR\x05appIdB\t\xe2\xde\x1f\x05AppID\"\x84\x02\n\x0bApplication\
    \x12\x20\n\x06app_id\x18\x01\x20\x01(\tR\x05appIdB\t\xe2\xde\x1f\x05AppI\
    D\x12%\n\x0epayload_format\x18\x06\x20\x01(\tR\rpayloadFormat\x12\x18\n\
    \x07decoder\x18\x02\x20\x01(\tR\x07decoder\x12\x1c\n\tconverter\x18\x03\
    \x20\x01(\tR\tconverter\x12\x1c\n\tvalidator\x18\x04\x20\x01(\tR\tvalida\
    tor\x12\x18\n\x07encoder\x18\x05\x20\x01(\tR\x07encoder\x12<\n\x1bregist\
    er_on_join_access_key\x18\x07\x20\x01(\tR\x17registerOnJoinAccessKey\"V\
    \n\x10DeviceIdentifier\x12\x20\n\x06app_id\x18\x01\x20\x01(\tR\x05appIdB\
    \t\xe2\xde\x1f\x05AppID\x12\x20\n\x06dev_id\x18\x02\x20\x01(\tR\x05devId\
    B\t\xe2\xde\x1f\x05DevID\"\x9b\x03\n\x06Device\x12\x20\n\x06app_id\x18\
    \x01\x20\x01(\tR\x05appIdB\t\xe2\xde\x1f\x05AppID\x12\x20\n\x06dev_id\
    \x18\x02\x20\x01(\tR\x05devIdB\t\xe2\xde\x1f\x05DevID\x12K\n\x0elorawan_\
    device\x18\x03\x20\x01(\x0b2\x0f.lorawan.DeviceH\0R\rlorawanDeviceB\x11\
    \xe2\xde\x1f\rLoRaWANDevice\x12\x1a\n\x08latitude\x18\n\x20\x01(\x02R\
    \x08latitude\x12\x1c\n\tlongitude\x18\x0b\x20\x01(\x02R\tlongitude\x12\
    \x1a\n\x08altitude\x18\x0c\x20\x01(\x05R\x08altitude\x12?\n\nattributes\
    \x18\r\x20\x03(\x0b2\x1f.handler.Device.AttributesEntryR\nattributes\x12\
    \x20\n\x0bdescription\x18\x14\x20\x01(\tR\x0bdescription\x1a=\n\x0fAttri\
    butesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05valu\
    e\x18\x02\x20\x01(\tR\x05value:\x028\x01B\x08\n\x06device\"7\n\nDeviceLi\
    st\x12)\n\x07devices\x18\x01\x20\x03(\x0b2\x0f.handler.DeviceR\x07device\
    s\"\x88\x01\n\x12DryDownlinkMessage\x12\x18\n\x07payload\x18\x01\x20\x01\
    (\x0cR\x07payload\x12\x16\n\x06fields\x18\x02\x20\x01(\tR\x06fields\x12,\
    \n\x03app\x18\x03\x20\x01(\x0b2\x14.handler.ApplicationR\x03appB\x04\xc8\
    \xde\x1f\0\x12\x12\n\x04port\x18\x04\x20\x01(\rR\x04port\"n\n\x10DryUpli\
    nkMessage\x12\x18\n\x07payload\x18\x01\x20\x01(\x0cR\x07payload\x12,\n\
    \x03app\x18\x02\x20\x01(\x0b2\x14.handler.ApplicationR\x03appB\x04\xc8\
    \xde\x1f\0\x12\x12\n\x04port\x18\x03\x20\x01(\rR\x04port\"\x8a\x01\n\x16\
    SimulatedUplinkMessage\x12\x20\n\x06app_id\x18\x01\x20\x01(\tR\x05appIdB\
    \t\xe2\xde\x1f\x05AppID\x12\x20\n\x06dev_id\x18\x02\x20\x01(\tR\x05devId\
    B\t\xe2\xde\x1f\x05DevID\x12\x18\n\x07payload\x18\x03\x20\x01(\x0cR\x07p\
    ayload\x12\x12\n\x04port\x18\x04\x20\x01(\rR\x04port\">\n\x08LogEntry\
    \x12\x1a\n\x08function\x18\x01\x20\x01(\tR\x08function\x12\x16\n\x06fiel\
    ds\x18\x02\x20\x03(\tR\x06fields\"\x80\x01\n\x0fDryUplinkResult\x12\x18\
    \n\x07payload\x18\x01\x20\x01(\x0cR\x07payload\x12\x16\n\x06fields\x18\
    \x02\x20\x01(\tR\x06fields\x12\x14\n\x05valid\x18\x03\x20\x01(\x08R\x05v\
    alid\x12%\n\x04logs\x18\x04\x20\x03(\x0b2\x11.handler.LogEntryR\x04logs\
    \"T\n\x11DryDownlinkResult\x12\x18\n\x07payload\x18\x01\x20\x01(\x0cR\
    \x07payload\x12%\n\x04logs\x18\x02\x20\x03(\x0b2\x11.handler.LogEntryR\
    \x04logs2\xc5\x01\n\x07Handler\x12^\n\x13ActivationChallenge\x12\".broke\
    r.ActivationChallengeRequest\x1a#.broker.ActivationChallengeResponse\x12\
    Z\n\x08Activate\x12+.broker.DeduplicatedDeviceActivationRequest\x1a!.han\
    dler.DeviceActivationResponse2\xe3\t\n\x12ApplicationManager\x12g\n\x13R\
    egisterApplication\x12\x1e.handler.ApplicationIdentifier\x1a\x16.google.\
    protobuf.Empty\"\x18\x82\xd3\xe4\x93\x02\x12\"\r/applications:\x01*\x12f\
    \n\x0eGetApplication\x12\x1e.handler.ApplicationIdentifier\x1a\x14.handl\
    er.Application\"\x1e\x82\xd3\xe4\x93\x02\x18\x12\x16/applications/{app_i\
    d}\x12~\n\x0eSetApplication\x12\x14.handler.Application\x1a\x16.google.p\
    rotobuf.Empty\">\x82\xd3\xe4\x93\x028\"\x16/applications/{app_id}:\x01*Z\
    \x1b\x1a\x16/applications/{app_id}:\x01*\x12k\n\x11DeleteApplication\x12\
    \x1e.handler.ApplicationIdentifier\x1a\x16.google.protobuf.Empty\"\x1e\
    \x82\xd3\xe4\x93\x02\x18*\x16/applications/{app_id}\x12h\n\tGetDevice\
    \x12\x19.handler.DeviceIdentifier\x1a\x0f.handler.Device\"/\x82\xd3\xe4\
    \x93\x02)\x12'/applications/{app_id}/devices/{dev_id}\x12\xe2\x01\n\tSet\
    Device\x12\x0f.handler.Device\x1a\x16.google.protobuf.Empty\"\xab\x01\
    \x82\xd3\xe4\x93\x02\xa4\x01\"'/applications/{app_id}/devices/{dev_id}:\
    \x01*Z,\x1a'/applications/{app_id}/devices/{dev_id}:\x01*Z#\"\x1e/applic\
    ations/{app_id}/devices:\x01*Z#\x1a\x1e/applications/{app_id}/devices:\
    \x01*\x12r\n\x0cDeleteDevice\x12\x19.handler.DeviceIdentifier\x1a\x16.go\
    ogle.protobuf.Empty\"/\x82\xd3\xe4\x93\x02)*'/applications/{app_id}/devi\
    ces/{dev_id}\x12w\n\x18GetDevicesForApplication\x12\x1e.handler.Applicat\
    ionIdentifier\x1a\x13.handler.DeviceList\"&\x82\xd3\xe4\x93\x02\x20\x12\
    \x1e/applications/{app_id}/devices\x12F\n\x0bDryDownlink\x12\x1b.handler\
    .DryDownlinkMessage\x1a\x1a.handler.DryDownlinkResult\x12@\n\tDryUplink\
    \x12\x19.handler.DryUplinkMessage\x1a\x18.handler.DryUplinkResult\x12I\n\
    \x0eSimulateUplink\x12\x1f.handler.SimulatedUplinkMessage\x1a\x16.google\
    .protobuf.Empty2F\n\x0eHandlerManager\x124\n\tGetStatus\x12\x16.handler.\
    StatusRequest\x1a\x0f.handler.StatusBz\n\x20org.thethingsnetwork.api.han\
    dlerB\x0cHandlerProtoP\x01Z'github.com/TheThingsNetwork/api/handler\xaa\
    \x02\x1cTheThingsNetwork.API.Handlerb\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
