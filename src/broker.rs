// This file is generated by rust-protobuf 2.6.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct DownlinkOption {
    // message fields
    pub identifier: ::std::string::String,
    pub gateway_id: ::std::string::String,
    pub score: u32,
    pub deadline: i64,
    pub protocol_configuration: ::protobuf::SingularPtrField<super::protocol::TxConfiguration>,
    pub gateway_configuration: ::protobuf::SingularPtrField<super::gateway::TxConfiguration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DownlinkOption {
    fn default() -> &'a DownlinkOption {
        <DownlinkOption as ::protobuf::Message>::default_instance()
    }
}

impl DownlinkOption {
    pub fn new() -> DownlinkOption {
        ::std::default::Default::default()
    }

    // string identifier = 1;


    pub fn get_identifier(&self) -> &str {
        &self.identifier
    }
    pub fn clear_identifier(&mut self) {
        self.identifier.clear();
    }

    // Param is passed by value, moved
    pub fn set_identifier(&mut self, v: ::std::string::String) {
        self.identifier = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identifier(&mut self) -> &mut ::std::string::String {
        &mut self.identifier
    }

    // Take field
    pub fn take_identifier(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.identifier, ::std::string::String::new())
    }

    // string gateway_id = 2;


    pub fn get_gateway_id(&self) -> &str {
        &self.gateway_id
    }
    pub fn clear_gateway_id(&mut self) {
        self.gateway_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_gateway_id(&mut self, v: ::std::string::String) {
        self.gateway_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gateway_id(&mut self) -> &mut ::std::string::String {
        &mut self.gateway_id
    }

    // Take field
    pub fn take_gateway_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.gateway_id, ::std::string::String::new())
    }

    // uint32 score = 3;


    pub fn get_score(&self) -> u32 {
        self.score
    }
    pub fn clear_score(&mut self) {
        self.score = 0;
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: u32) {
        self.score = v;
    }

    // int64 deadline = 4;


    pub fn get_deadline(&self) -> i64 {
        self.deadline
    }
    pub fn clear_deadline(&mut self) {
        self.deadline = 0;
    }

    // Param is passed by value, moved
    pub fn set_deadline(&mut self, v: i64) {
        self.deadline = v;
    }

    // .protocol.TxConfiguration protocol_configuration = 5;


    pub fn get_protocol_configuration(&self) -> &super::protocol::TxConfiguration {
        self.protocol_configuration.as_ref().unwrap_or_else(|| super::protocol::TxConfiguration::default_instance())
    }
    pub fn clear_protocol_configuration(&mut self) {
        self.protocol_configuration.clear();
    }

    pub fn has_protocol_configuration(&self) -> bool {
        self.protocol_configuration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_configuration(&mut self, v: super::protocol::TxConfiguration) {
        self.protocol_configuration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocol_configuration(&mut self) -> &mut super::protocol::TxConfiguration {
        if self.protocol_configuration.is_none() {
            self.protocol_configuration.set_default();
        }
        self.protocol_configuration.as_mut().unwrap()
    }

    // Take field
    pub fn take_protocol_configuration(&mut self) -> super::protocol::TxConfiguration {
        self.protocol_configuration.take().unwrap_or_else(|| super::protocol::TxConfiguration::new())
    }

    // .gateway.TxConfiguration gateway_configuration = 6;


    pub fn get_gateway_configuration(&self) -> &super::gateway::TxConfiguration {
        self.gateway_configuration.as_ref().unwrap_or_else(|| super::gateway::TxConfiguration::default_instance())
    }
    pub fn clear_gateway_configuration(&mut self) {
        self.gateway_configuration.clear();
    }

    pub fn has_gateway_configuration(&self) -> bool {
        self.gateway_configuration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gateway_configuration(&mut self, v: super::gateway::TxConfiguration) {
        self.gateway_configuration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gateway_configuration(&mut self) -> &mut super::gateway::TxConfiguration {
        if self.gateway_configuration.is_none() {
            self.gateway_configuration.set_default();
        }
        self.gateway_configuration.as_mut().unwrap()
    }

    // Take field
    pub fn take_gateway_configuration(&mut self) -> super::gateway::TxConfiguration {
        self.gateway_configuration.take().unwrap_or_else(|| super::gateway::TxConfiguration::new())
    }
}

impl ::protobuf::Message for DownlinkOption {
    fn is_initialized(&self) -> bool {
        for v in &self.protocol_configuration {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.gateway_configuration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.identifier)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.gateway_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.score = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.deadline = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.protocol_configuration)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.gateway_configuration)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.identifier.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.identifier);
        }
        if !self.gateway_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.gateway_id);
        }
        if self.score != 0 {
            my_size += ::protobuf::rt::value_size(3, self.score, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.deadline != 0 {
            my_size += ::protobuf::rt::value_size(4, self.deadline, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.protocol_configuration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.gateway_configuration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.identifier.is_empty() {
            os.write_string(1, &self.identifier)?;
        }
        if !self.gateway_id.is_empty() {
            os.write_string(2, &self.gateway_id)?;
        }
        if self.score != 0 {
            os.write_uint32(3, self.score)?;
        }
        if self.deadline != 0 {
            os.write_int64(4, self.deadline)?;
        }
        if let Some(ref v) = self.protocol_configuration.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.gateway_configuration.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DownlinkOption {
        DownlinkOption::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "identifier",
                    |m: &DownlinkOption| { &m.identifier },
                    |m: &mut DownlinkOption| { &mut m.identifier },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gateway_id",
                    |m: &DownlinkOption| { &m.gateway_id },
                    |m: &mut DownlinkOption| { &mut m.gateway_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "score",
                    |m: &DownlinkOption| { &m.score },
                    |m: &mut DownlinkOption| { &mut m.score },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "deadline",
                    |m: &DownlinkOption| { &m.deadline },
                    |m: &mut DownlinkOption| { &mut m.deadline },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::protocol::TxConfiguration>>(
                    "protocol_configuration",
                    |m: &DownlinkOption| { &m.protocol_configuration },
                    |m: &mut DownlinkOption| { &mut m.protocol_configuration },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::gateway::TxConfiguration>>(
                    "gateway_configuration",
                    |m: &DownlinkOption| { &m.gateway_configuration },
                    |m: &mut DownlinkOption| { &mut m.gateway_configuration },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DownlinkOption>(
                    "DownlinkOption",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DownlinkOption {
        static mut instance: ::protobuf::lazy::Lazy<DownlinkOption> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DownlinkOption,
        };
        unsafe {
            instance.get(DownlinkOption::new)
        }
    }
}

impl ::protobuf::Clear for DownlinkOption {
    fn clear(&mut self) {
        self.identifier.clear();
        self.gateway_id.clear();
        self.score = 0;
        self.deadline = 0;
        self.protocol_configuration.clear();
        self.gateway_configuration.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DownlinkOption {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DownlinkOption {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UplinkMessage {
    // message fields
    pub payload: ::std::vec::Vec<u8>,
    pub message: ::protobuf::SingularPtrField<super::protocol::Message>,
    pub dev_eui: ::std::vec::Vec<u8>,
    pub app_eui: ::std::vec::Vec<u8>,
    pub app_id: ::std::string::String,
    pub dev_id: ::std::string::String,
    pub protocol_metadata: ::protobuf::SingularPtrField<super::protocol::RxMetadata>,
    pub gateway_metadata: ::protobuf::SingularPtrField<super::gateway::RxMetadata>,
    pub downlink_options: ::protobuf::RepeatedField<DownlinkOption>,
    pub trace: ::protobuf::SingularPtrField<super::trace::Trace>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UplinkMessage {
    fn default() -> &'a UplinkMessage {
        <UplinkMessage as ::protobuf::Message>::default_instance()
    }
}

impl UplinkMessage {
    pub fn new() -> UplinkMessage {
        ::std::default::Default::default()
    }

    // bytes payload = 1;


    pub fn get_payload(&self) -> &[u8] {
        &self.payload
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payload
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payload, ::std::vec::Vec::new())
    }

    // .protocol.Message message = 2;


    pub fn get_message(&self) -> &super::protocol::Message {
        self.message.as_ref().unwrap_or_else(|| super::protocol::Message::default_instance())
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: super::protocol::Message) {
        self.message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut super::protocol::Message {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> super::protocol::Message {
        self.message.take().unwrap_or_else(|| super::protocol::Message::new())
    }

    // bytes dev_eui = 11;


    pub fn get_dev_eui(&self) -> &[u8] {
        &self.dev_eui
    }
    pub fn clear_dev_eui(&mut self) {
        self.dev_eui.clear();
    }

    // Param is passed by value, moved
    pub fn set_dev_eui(&mut self, v: ::std::vec::Vec<u8>) {
        self.dev_eui = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dev_eui(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.dev_eui
    }

    // Take field
    pub fn take_dev_eui(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.dev_eui, ::std::vec::Vec::new())
    }

    // bytes app_eui = 12;


    pub fn get_app_eui(&self) -> &[u8] {
        &self.app_eui
    }
    pub fn clear_app_eui(&mut self) {
        self.app_eui.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_eui(&mut self, v: ::std::vec::Vec<u8>) {
        self.app_eui = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_eui(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.app_eui
    }

    // Take field
    pub fn take_app_eui(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.app_eui, ::std::vec::Vec::new())
    }

    // string app_id = 13;


    pub fn get_app_id(&self) -> &str {
        &self.app_id
    }
    pub fn clear_app_id(&mut self) {
        self.app_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: ::std::string::String) {
        self.app_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_id(&mut self) -> &mut ::std::string::String {
        &mut self.app_id
    }

    // Take field
    pub fn take_app_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.app_id, ::std::string::String::new())
    }

    // string dev_id = 14;


    pub fn get_dev_id(&self) -> &str {
        &self.dev_id
    }
    pub fn clear_dev_id(&mut self) {
        self.dev_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_dev_id(&mut self, v: ::std::string::String) {
        self.dev_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dev_id(&mut self) -> &mut ::std::string::String {
        &mut self.dev_id
    }

    // Take field
    pub fn take_dev_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dev_id, ::std::string::String::new())
    }

    // .protocol.RxMetadata protocol_metadata = 21;


    pub fn get_protocol_metadata(&self) -> &super::protocol::RxMetadata {
        self.protocol_metadata.as_ref().unwrap_or_else(|| super::protocol::RxMetadata::default_instance())
    }
    pub fn clear_protocol_metadata(&mut self) {
        self.protocol_metadata.clear();
    }

    pub fn has_protocol_metadata(&self) -> bool {
        self.protocol_metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_metadata(&mut self, v: super::protocol::RxMetadata) {
        self.protocol_metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocol_metadata(&mut self) -> &mut super::protocol::RxMetadata {
        if self.protocol_metadata.is_none() {
            self.protocol_metadata.set_default();
        }
        self.protocol_metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_protocol_metadata(&mut self) -> super::protocol::RxMetadata {
        self.protocol_metadata.take().unwrap_or_else(|| super::protocol::RxMetadata::new())
    }

    // .gateway.RxMetadata gateway_metadata = 22;


    pub fn get_gateway_metadata(&self) -> &super::gateway::RxMetadata {
        self.gateway_metadata.as_ref().unwrap_or_else(|| super::gateway::RxMetadata::default_instance())
    }
    pub fn clear_gateway_metadata(&mut self) {
        self.gateway_metadata.clear();
    }

    pub fn has_gateway_metadata(&self) -> bool {
        self.gateway_metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gateway_metadata(&mut self, v: super::gateway::RxMetadata) {
        self.gateway_metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gateway_metadata(&mut self) -> &mut super::gateway::RxMetadata {
        if self.gateway_metadata.is_none() {
            self.gateway_metadata.set_default();
        }
        self.gateway_metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_gateway_metadata(&mut self) -> super::gateway::RxMetadata {
        self.gateway_metadata.take().unwrap_or_else(|| super::gateway::RxMetadata::new())
    }

    // repeated .broker.DownlinkOption downlink_options = 31;


    pub fn get_downlink_options(&self) -> &[DownlinkOption] {
        &self.downlink_options
    }
    pub fn clear_downlink_options(&mut self) {
        self.downlink_options.clear();
    }

    // Param is passed by value, moved
    pub fn set_downlink_options(&mut self, v: ::protobuf::RepeatedField<DownlinkOption>) {
        self.downlink_options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_downlink_options(&mut self) -> &mut ::protobuf::RepeatedField<DownlinkOption> {
        &mut self.downlink_options
    }

    // Take field
    pub fn take_downlink_options(&mut self) -> ::protobuf::RepeatedField<DownlinkOption> {
        ::std::mem::replace(&mut self.downlink_options, ::protobuf::RepeatedField::new())
    }

    // .trace.Trace trace = 41;


    pub fn get_trace(&self) -> &super::trace::Trace {
        self.trace.as_ref().unwrap_or_else(|| super::trace::Trace::default_instance())
    }
    pub fn clear_trace(&mut self) {
        self.trace.clear();
    }

    pub fn has_trace(&self) -> bool {
        self.trace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trace(&mut self, v: super::trace::Trace) {
        self.trace = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trace(&mut self) -> &mut super::trace::Trace {
        if self.trace.is_none() {
            self.trace.set_default();
        }
        self.trace.as_mut().unwrap()
    }

    // Take field
    pub fn take_trace(&mut self) -> super::trace::Trace {
        self.trace.take().unwrap_or_else(|| super::trace::Trace::new())
    }
}

impl ::protobuf::Message for UplinkMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.message {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.protocol_metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.gateway_metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.downlink_options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.trace {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payload)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.dev_eui)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.app_eui)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.app_id)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dev_id)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.protocol_metadata)?;
                },
                22 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.gateway_metadata)?;
                },
                31 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.downlink_options)?;
                },
                41 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.trace)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.payload);
        }
        if let Some(ref v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.dev_eui.is_empty() {
            my_size += ::protobuf::rt::bytes_size(11, &self.dev_eui);
        }
        if !self.app_eui.is_empty() {
            my_size += ::protobuf::rt::bytes_size(12, &self.app_eui);
        }
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.app_id);
        }
        if !self.dev_id.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.dev_id);
        }
        if let Some(ref v) = self.protocol_metadata.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.gateway_metadata.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.downlink_options {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.trace.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.payload.is_empty() {
            os.write_bytes(1, &self.payload)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.dev_eui.is_empty() {
            os.write_bytes(11, &self.dev_eui)?;
        }
        if !self.app_eui.is_empty() {
            os.write_bytes(12, &self.app_eui)?;
        }
        if !self.app_id.is_empty() {
            os.write_string(13, &self.app_id)?;
        }
        if !self.dev_id.is_empty() {
            os.write_string(14, &self.dev_id)?;
        }
        if let Some(ref v) = self.protocol_metadata.as_ref() {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.gateway_metadata.as_ref() {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.downlink_options {
            os.write_tag(31, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.trace.as_ref() {
            os.write_tag(41, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UplinkMessage {
        UplinkMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payload",
                    |m: &UplinkMessage| { &m.payload },
                    |m: &mut UplinkMessage| { &mut m.payload },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::protocol::Message>>(
                    "message",
                    |m: &UplinkMessage| { &m.message },
                    |m: &mut UplinkMessage| { &mut m.message },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "dev_eui",
                    |m: &UplinkMessage| { &m.dev_eui },
                    |m: &mut UplinkMessage| { &mut m.dev_eui },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "app_eui",
                    |m: &UplinkMessage| { &m.app_eui },
                    |m: &mut UplinkMessage| { &mut m.app_eui },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "app_id",
                    |m: &UplinkMessage| { &m.app_id },
                    |m: &mut UplinkMessage| { &mut m.app_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dev_id",
                    |m: &UplinkMessage| { &m.dev_id },
                    |m: &mut UplinkMessage| { &mut m.dev_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::protocol::RxMetadata>>(
                    "protocol_metadata",
                    |m: &UplinkMessage| { &m.protocol_metadata },
                    |m: &mut UplinkMessage| { &mut m.protocol_metadata },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::gateway::RxMetadata>>(
                    "gateway_metadata",
                    |m: &UplinkMessage| { &m.gateway_metadata },
                    |m: &mut UplinkMessage| { &mut m.gateway_metadata },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DownlinkOption>>(
                    "downlink_options",
                    |m: &UplinkMessage| { &m.downlink_options },
                    |m: &mut UplinkMessage| { &mut m.downlink_options },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::trace::Trace>>(
                    "trace",
                    |m: &UplinkMessage| { &m.trace },
                    |m: &mut UplinkMessage| { &mut m.trace },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UplinkMessage>(
                    "UplinkMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UplinkMessage {
        static mut instance: ::protobuf::lazy::Lazy<UplinkMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UplinkMessage,
        };
        unsafe {
            instance.get(UplinkMessage::new)
        }
    }
}

impl ::protobuf::Clear for UplinkMessage {
    fn clear(&mut self) {
        self.payload.clear();
        self.message.clear();
        self.dev_eui.clear();
        self.app_eui.clear();
        self.app_id.clear();
        self.dev_id.clear();
        self.protocol_metadata.clear();
        self.gateway_metadata.clear();
        self.downlink_options.clear();
        self.trace.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UplinkMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UplinkMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DownlinkMessage {
    // message fields
    pub payload: ::std::vec::Vec<u8>,
    pub message: ::protobuf::SingularPtrField<super::protocol::Message>,
    pub dev_eui: ::std::vec::Vec<u8>,
    pub app_eui: ::std::vec::Vec<u8>,
    pub app_id: ::std::string::String,
    pub dev_id: ::std::string::String,
    pub downlink_option: ::protobuf::SingularPtrField<DownlinkOption>,
    pub trace: ::protobuf::SingularPtrField<super::trace::Trace>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DownlinkMessage {
    fn default() -> &'a DownlinkMessage {
        <DownlinkMessage as ::protobuf::Message>::default_instance()
    }
}

impl DownlinkMessage {
    pub fn new() -> DownlinkMessage {
        ::std::default::Default::default()
    }

    // bytes payload = 1;


    pub fn get_payload(&self) -> &[u8] {
        &self.payload
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payload
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payload, ::std::vec::Vec::new())
    }

    // .protocol.Message message = 2;


    pub fn get_message(&self) -> &super::protocol::Message {
        self.message.as_ref().unwrap_or_else(|| super::protocol::Message::default_instance())
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: super::protocol::Message) {
        self.message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut super::protocol::Message {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> super::protocol::Message {
        self.message.take().unwrap_or_else(|| super::protocol::Message::new())
    }

    // bytes dev_eui = 11;


    pub fn get_dev_eui(&self) -> &[u8] {
        &self.dev_eui
    }
    pub fn clear_dev_eui(&mut self) {
        self.dev_eui.clear();
    }

    // Param is passed by value, moved
    pub fn set_dev_eui(&mut self, v: ::std::vec::Vec<u8>) {
        self.dev_eui = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dev_eui(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.dev_eui
    }

    // Take field
    pub fn take_dev_eui(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.dev_eui, ::std::vec::Vec::new())
    }

    // bytes app_eui = 12;


    pub fn get_app_eui(&self) -> &[u8] {
        &self.app_eui
    }
    pub fn clear_app_eui(&mut self) {
        self.app_eui.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_eui(&mut self, v: ::std::vec::Vec<u8>) {
        self.app_eui = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_eui(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.app_eui
    }

    // Take field
    pub fn take_app_eui(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.app_eui, ::std::vec::Vec::new())
    }

    // string app_id = 13;


    pub fn get_app_id(&self) -> &str {
        &self.app_id
    }
    pub fn clear_app_id(&mut self) {
        self.app_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: ::std::string::String) {
        self.app_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_id(&mut self) -> &mut ::std::string::String {
        &mut self.app_id
    }

    // Take field
    pub fn take_app_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.app_id, ::std::string::String::new())
    }

    // string dev_id = 14;


    pub fn get_dev_id(&self) -> &str {
        &self.dev_id
    }
    pub fn clear_dev_id(&mut self) {
        self.dev_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_dev_id(&mut self, v: ::std::string::String) {
        self.dev_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dev_id(&mut self) -> &mut ::std::string::String {
        &mut self.dev_id
    }

    // Take field
    pub fn take_dev_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dev_id, ::std::string::String::new())
    }

    // .broker.DownlinkOption downlink_option = 21;


    pub fn get_downlink_option(&self) -> &DownlinkOption {
        self.downlink_option.as_ref().unwrap_or_else(|| DownlinkOption::default_instance())
    }
    pub fn clear_downlink_option(&mut self) {
        self.downlink_option.clear();
    }

    pub fn has_downlink_option(&self) -> bool {
        self.downlink_option.is_some()
    }

    // Param is passed by value, moved
    pub fn set_downlink_option(&mut self, v: DownlinkOption) {
        self.downlink_option = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_downlink_option(&mut self) -> &mut DownlinkOption {
        if self.downlink_option.is_none() {
            self.downlink_option.set_default();
        }
        self.downlink_option.as_mut().unwrap()
    }

    // Take field
    pub fn take_downlink_option(&mut self) -> DownlinkOption {
        self.downlink_option.take().unwrap_or_else(|| DownlinkOption::new())
    }

    // .trace.Trace trace = 31;


    pub fn get_trace(&self) -> &super::trace::Trace {
        self.trace.as_ref().unwrap_or_else(|| super::trace::Trace::default_instance())
    }
    pub fn clear_trace(&mut self) {
        self.trace.clear();
    }

    pub fn has_trace(&self) -> bool {
        self.trace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trace(&mut self, v: super::trace::Trace) {
        self.trace = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trace(&mut self) -> &mut super::trace::Trace {
        if self.trace.is_none() {
            self.trace.set_default();
        }
        self.trace.as_mut().unwrap()
    }

    // Take field
    pub fn take_trace(&mut self) -> super::trace::Trace {
        self.trace.take().unwrap_or_else(|| super::trace::Trace::new())
    }
}

impl ::protobuf::Message for DownlinkMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.message {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.downlink_option {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.trace {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payload)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.dev_eui)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.app_eui)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.app_id)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dev_id)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.downlink_option)?;
                },
                31 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.trace)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.payload);
        }
        if let Some(ref v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.dev_eui.is_empty() {
            my_size += ::protobuf::rt::bytes_size(11, &self.dev_eui);
        }
        if !self.app_eui.is_empty() {
            my_size += ::protobuf::rt::bytes_size(12, &self.app_eui);
        }
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.app_id);
        }
        if !self.dev_id.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.dev_id);
        }
        if let Some(ref v) = self.downlink_option.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.trace.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.payload.is_empty() {
            os.write_bytes(1, &self.payload)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.dev_eui.is_empty() {
            os.write_bytes(11, &self.dev_eui)?;
        }
        if !self.app_eui.is_empty() {
            os.write_bytes(12, &self.app_eui)?;
        }
        if !self.app_id.is_empty() {
            os.write_string(13, &self.app_id)?;
        }
        if !self.dev_id.is_empty() {
            os.write_string(14, &self.dev_id)?;
        }
        if let Some(ref v) = self.downlink_option.as_ref() {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.trace.as_ref() {
            os.write_tag(31, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DownlinkMessage {
        DownlinkMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payload",
                    |m: &DownlinkMessage| { &m.payload },
                    |m: &mut DownlinkMessage| { &mut m.payload },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::protocol::Message>>(
                    "message",
                    |m: &DownlinkMessage| { &m.message },
                    |m: &mut DownlinkMessage| { &mut m.message },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "dev_eui",
                    |m: &DownlinkMessage| { &m.dev_eui },
                    |m: &mut DownlinkMessage| { &mut m.dev_eui },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "app_eui",
                    |m: &DownlinkMessage| { &m.app_eui },
                    |m: &mut DownlinkMessage| { &mut m.app_eui },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "app_id",
                    |m: &DownlinkMessage| { &m.app_id },
                    |m: &mut DownlinkMessage| { &mut m.app_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dev_id",
                    |m: &DownlinkMessage| { &m.dev_id },
                    |m: &mut DownlinkMessage| { &mut m.dev_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DownlinkOption>>(
                    "downlink_option",
                    |m: &DownlinkMessage| { &m.downlink_option },
                    |m: &mut DownlinkMessage| { &mut m.downlink_option },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::trace::Trace>>(
                    "trace",
                    |m: &DownlinkMessage| { &m.trace },
                    |m: &mut DownlinkMessage| { &mut m.trace },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DownlinkMessage>(
                    "DownlinkMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DownlinkMessage {
        static mut instance: ::protobuf::lazy::Lazy<DownlinkMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DownlinkMessage,
        };
        unsafe {
            instance.get(DownlinkMessage::new)
        }
    }
}

impl ::protobuf::Clear for DownlinkMessage {
    fn clear(&mut self) {
        self.payload.clear();
        self.message.clear();
        self.dev_eui.clear();
        self.app_eui.clear();
        self.app_id.clear();
        self.dev_id.clear();
        self.downlink_option.clear();
        self.trace.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DownlinkMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DownlinkMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeviceActivationResponse {
    // message fields
    pub payload: ::std::vec::Vec<u8>,
    pub message: ::protobuf::SingularPtrField<super::protocol::Message>,
    pub downlink_option: ::protobuf::SingularPtrField<DownlinkOption>,
    pub trace: ::protobuf::SingularPtrField<super::trace::Trace>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeviceActivationResponse {
    fn default() -> &'a DeviceActivationResponse {
        <DeviceActivationResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeviceActivationResponse {
    pub fn new() -> DeviceActivationResponse {
        ::std::default::Default::default()
    }

    // bytes payload = 1;


    pub fn get_payload(&self) -> &[u8] {
        &self.payload
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payload
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payload, ::std::vec::Vec::new())
    }

    // .protocol.Message message = 2;


    pub fn get_message(&self) -> &super::protocol::Message {
        self.message.as_ref().unwrap_or_else(|| super::protocol::Message::default_instance())
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: super::protocol::Message) {
        self.message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut super::protocol::Message {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> super::protocol::Message {
        self.message.take().unwrap_or_else(|| super::protocol::Message::new())
    }

    // .broker.DownlinkOption downlink_option = 11;


    pub fn get_downlink_option(&self) -> &DownlinkOption {
        self.downlink_option.as_ref().unwrap_or_else(|| DownlinkOption::default_instance())
    }
    pub fn clear_downlink_option(&mut self) {
        self.downlink_option.clear();
    }

    pub fn has_downlink_option(&self) -> bool {
        self.downlink_option.is_some()
    }

    // Param is passed by value, moved
    pub fn set_downlink_option(&mut self, v: DownlinkOption) {
        self.downlink_option = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_downlink_option(&mut self) -> &mut DownlinkOption {
        if self.downlink_option.is_none() {
            self.downlink_option.set_default();
        }
        self.downlink_option.as_mut().unwrap()
    }

    // Take field
    pub fn take_downlink_option(&mut self) -> DownlinkOption {
        self.downlink_option.take().unwrap_or_else(|| DownlinkOption::new())
    }

    // .trace.Trace trace = 21;


    pub fn get_trace(&self) -> &super::trace::Trace {
        self.trace.as_ref().unwrap_or_else(|| super::trace::Trace::default_instance())
    }
    pub fn clear_trace(&mut self) {
        self.trace.clear();
    }

    pub fn has_trace(&self) -> bool {
        self.trace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trace(&mut self, v: super::trace::Trace) {
        self.trace = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trace(&mut self) -> &mut super::trace::Trace {
        if self.trace.is_none() {
            self.trace.set_default();
        }
        self.trace.as_mut().unwrap()
    }

    // Take field
    pub fn take_trace(&mut self) -> super::trace::Trace {
        self.trace.take().unwrap_or_else(|| super::trace::Trace::new())
    }
}

impl ::protobuf::Message for DeviceActivationResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.message {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.downlink_option {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.trace {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payload)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.downlink_option)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.trace)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.payload);
        }
        if let Some(ref v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.downlink_option.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.trace.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.payload.is_empty() {
            os.write_bytes(1, &self.payload)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.downlink_option.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.trace.as_ref() {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeviceActivationResponse {
        DeviceActivationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payload",
                    |m: &DeviceActivationResponse| { &m.payload },
                    |m: &mut DeviceActivationResponse| { &mut m.payload },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::protocol::Message>>(
                    "message",
                    |m: &DeviceActivationResponse| { &m.message },
                    |m: &mut DeviceActivationResponse| { &mut m.message },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DownlinkOption>>(
                    "downlink_option",
                    |m: &DeviceActivationResponse| { &m.downlink_option },
                    |m: &mut DeviceActivationResponse| { &mut m.downlink_option },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::trace::Trace>>(
                    "trace",
                    |m: &DeviceActivationResponse| { &m.trace },
                    |m: &mut DeviceActivationResponse| { &mut m.trace },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeviceActivationResponse>(
                    "DeviceActivationResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeviceActivationResponse {
        static mut instance: ::protobuf::lazy::Lazy<DeviceActivationResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeviceActivationResponse,
        };
        unsafe {
            instance.get(DeviceActivationResponse::new)
        }
    }
}

impl ::protobuf::Clear for DeviceActivationResponse {
    fn clear(&mut self) {
        self.payload.clear();
        self.message.clear();
        self.downlink_option.clear();
        self.trace.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceActivationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceActivationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeduplicatedUplinkMessage {
    // message fields
    pub payload: ::std::vec::Vec<u8>,
    pub message: ::protobuf::SingularPtrField<super::protocol::Message>,
    pub dev_eui: ::std::vec::Vec<u8>,
    pub app_eui: ::std::vec::Vec<u8>,
    pub app_id: ::std::string::String,
    pub dev_id: ::std::string::String,
    pub protocol_metadata: ::protobuf::SingularPtrField<super::protocol::RxMetadata>,
    pub gateway_metadata: ::protobuf::RepeatedField<super::gateway::RxMetadata>,
    pub server_time: i64,
    pub response_template: ::protobuf::SingularPtrField<DownlinkMessage>,
    pub trace: ::protobuf::SingularPtrField<super::trace::Trace>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeduplicatedUplinkMessage {
    fn default() -> &'a DeduplicatedUplinkMessage {
        <DeduplicatedUplinkMessage as ::protobuf::Message>::default_instance()
    }
}

impl DeduplicatedUplinkMessage {
    pub fn new() -> DeduplicatedUplinkMessage {
        ::std::default::Default::default()
    }

    // bytes payload = 1;


    pub fn get_payload(&self) -> &[u8] {
        &self.payload
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payload
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payload, ::std::vec::Vec::new())
    }

    // .protocol.Message message = 2;


    pub fn get_message(&self) -> &super::protocol::Message {
        self.message.as_ref().unwrap_or_else(|| super::protocol::Message::default_instance())
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: super::protocol::Message) {
        self.message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut super::protocol::Message {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> super::protocol::Message {
        self.message.take().unwrap_or_else(|| super::protocol::Message::new())
    }

    // bytes dev_eui = 11;


    pub fn get_dev_eui(&self) -> &[u8] {
        &self.dev_eui
    }
    pub fn clear_dev_eui(&mut self) {
        self.dev_eui.clear();
    }

    // Param is passed by value, moved
    pub fn set_dev_eui(&mut self, v: ::std::vec::Vec<u8>) {
        self.dev_eui = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dev_eui(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.dev_eui
    }

    // Take field
    pub fn take_dev_eui(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.dev_eui, ::std::vec::Vec::new())
    }

    // bytes app_eui = 12;


    pub fn get_app_eui(&self) -> &[u8] {
        &self.app_eui
    }
    pub fn clear_app_eui(&mut self) {
        self.app_eui.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_eui(&mut self, v: ::std::vec::Vec<u8>) {
        self.app_eui = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_eui(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.app_eui
    }

    // Take field
    pub fn take_app_eui(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.app_eui, ::std::vec::Vec::new())
    }

    // string app_id = 13;


    pub fn get_app_id(&self) -> &str {
        &self.app_id
    }
    pub fn clear_app_id(&mut self) {
        self.app_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: ::std::string::String) {
        self.app_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_id(&mut self) -> &mut ::std::string::String {
        &mut self.app_id
    }

    // Take field
    pub fn take_app_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.app_id, ::std::string::String::new())
    }

    // string dev_id = 14;


    pub fn get_dev_id(&self) -> &str {
        &self.dev_id
    }
    pub fn clear_dev_id(&mut self) {
        self.dev_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_dev_id(&mut self, v: ::std::string::String) {
        self.dev_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dev_id(&mut self) -> &mut ::std::string::String {
        &mut self.dev_id
    }

    // Take field
    pub fn take_dev_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dev_id, ::std::string::String::new())
    }

    // .protocol.RxMetadata protocol_metadata = 21;


    pub fn get_protocol_metadata(&self) -> &super::protocol::RxMetadata {
        self.protocol_metadata.as_ref().unwrap_or_else(|| super::protocol::RxMetadata::default_instance())
    }
    pub fn clear_protocol_metadata(&mut self) {
        self.protocol_metadata.clear();
    }

    pub fn has_protocol_metadata(&self) -> bool {
        self.protocol_metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_metadata(&mut self, v: super::protocol::RxMetadata) {
        self.protocol_metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocol_metadata(&mut self) -> &mut super::protocol::RxMetadata {
        if self.protocol_metadata.is_none() {
            self.protocol_metadata.set_default();
        }
        self.protocol_metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_protocol_metadata(&mut self) -> super::protocol::RxMetadata {
        self.protocol_metadata.take().unwrap_or_else(|| super::protocol::RxMetadata::new())
    }

    // repeated .gateway.RxMetadata gateway_metadata = 22;


    pub fn get_gateway_metadata(&self) -> &[super::gateway::RxMetadata] {
        &self.gateway_metadata
    }
    pub fn clear_gateway_metadata(&mut self) {
        self.gateway_metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_gateway_metadata(&mut self, v: ::protobuf::RepeatedField<super::gateway::RxMetadata>) {
        self.gateway_metadata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_gateway_metadata(&mut self) -> &mut ::protobuf::RepeatedField<super::gateway::RxMetadata> {
        &mut self.gateway_metadata
    }

    // Take field
    pub fn take_gateway_metadata(&mut self) -> ::protobuf::RepeatedField<super::gateway::RxMetadata> {
        ::std::mem::replace(&mut self.gateway_metadata, ::protobuf::RepeatedField::new())
    }

    // int64 server_time = 23;


    pub fn get_server_time(&self) -> i64 {
        self.server_time
    }
    pub fn clear_server_time(&mut self) {
        self.server_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_server_time(&mut self, v: i64) {
        self.server_time = v;
    }

    // .broker.DownlinkMessage response_template = 31;


    pub fn get_response_template(&self) -> &DownlinkMessage {
        self.response_template.as_ref().unwrap_or_else(|| DownlinkMessage::default_instance())
    }
    pub fn clear_response_template(&mut self) {
        self.response_template.clear();
    }

    pub fn has_response_template(&self) -> bool {
        self.response_template.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response_template(&mut self, v: DownlinkMessage) {
        self.response_template = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_response_template(&mut self) -> &mut DownlinkMessage {
        if self.response_template.is_none() {
            self.response_template.set_default();
        }
        self.response_template.as_mut().unwrap()
    }

    // Take field
    pub fn take_response_template(&mut self) -> DownlinkMessage {
        self.response_template.take().unwrap_or_else(|| DownlinkMessage::new())
    }

    // .trace.Trace trace = 41;


    pub fn get_trace(&self) -> &super::trace::Trace {
        self.trace.as_ref().unwrap_or_else(|| super::trace::Trace::default_instance())
    }
    pub fn clear_trace(&mut self) {
        self.trace.clear();
    }

    pub fn has_trace(&self) -> bool {
        self.trace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trace(&mut self, v: super::trace::Trace) {
        self.trace = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trace(&mut self) -> &mut super::trace::Trace {
        if self.trace.is_none() {
            self.trace.set_default();
        }
        self.trace.as_mut().unwrap()
    }

    // Take field
    pub fn take_trace(&mut self) -> super::trace::Trace {
        self.trace.take().unwrap_or_else(|| super::trace::Trace::new())
    }
}

impl ::protobuf::Message for DeduplicatedUplinkMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.message {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.protocol_metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.gateway_metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.response_template {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.trace {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payload)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.dev_eui)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.app_eui)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.app_id)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dev_id)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.protocol_metadata)?;
                },
                22 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.gateway_metadata)?;
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.server_time = tmp;
                },
                31 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.response_template)?;
                },
                41 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.trace)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.payload);
        }
        if let Some(ref v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.dev_eui.is_empty() {
            my_size += ::protobuf::rt::bytes_size(11, &self.dev_eui);
        }
        if !self.app_eui.is_empty() {
            my_size += ::protobuf::rt::bytes_size(12, &self.app_eui);
        }
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.app_id);
        }
        if !self.dev_id.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.dev_id);
        }
        if let Some(ref v) = self.protocol_metadata.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.gateway_metadata {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.server_time != 0 {
            my_size += ::protobuf::rt::value_size(23, self.server_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.response_template.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.trace.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.payload.is_empty() {
            os.write_bytes(1, &self.payload)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.dev_eui.is_empty() {
            os.write_bytes(11, &self.dev_eui)?;
        }
        if !self.app_eui.is_empty() {
            os.write_bytes(12, &self.app_eui)?;
        }
        if !self.app_id.is_empty() {
            os.write_string(13, &self.app_id)?;
        }
        if !self.dev_id.is_empty() {
            os.write_string(14, &self.dev_id)?;
        }
        if let Some(ref v) = self.protocol_metadata.as_ref() {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.gateway_metadata {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.server_time != 0 {
            os.write_int64(23, self.server_time)?;
        }
        if let Some(ref v) = self.response_template.as_ref() {
            os.write_tag(31, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.trace.as_ref() {
            os.write_tag(41, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeduplicatedUplinkMessage {
        DeduplicatedUplinkMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payload",
                    |m: &DeduplicatedUplinkMessage| { &m.payload },
                    |m: &mut DeduplicatedUplinkMessage| { &mut m.payload },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::protocol::Message>>(
                    "message",
                    |m: &DeduplicatedUplinkMessage| { &m.message },
                    |m: &mut DeduplicatedUplinkMessage| { &mut m.message },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "dev_eui",
                    |m: &DeduplicatedUplinkMessage| { &m.dev_eui },
                    |m: &mut DeduplicatedUplinkMessage| { &mut m.dev_eui },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "app_eui",
                    |m: &DeduplicatedUplinkMessage| { &m.app_eui },
                    |m: &mut DeduplicatedUplinkMessage| { &mut m.app_eui },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "app_id",
                    |m: &DeduplicatedUplinkMessage| { &m.app_id },
                    |m: &mut DeduplicatedUplinkMessage| { &mut m.app_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dev_id",
                    |m: &DeduplicatedUplinkMessage| { &m.dev_id },
                    |m: &mut DeduplicatedUplinkMessage| { &mut m.dev_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::protocol::RxMetadata>>(
                    "protocol_metadata",
                    |m: &DeduplicatedUplinkMessage| { &m.protocol_metadata },
                    |m: &mut DeduplicatedUplinkMessage| { &mut m.protocol_metadata },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::gateway::RxMetadata>>(
                    "gateway_metadata",
                    |m: &DeduplicatedUplinkMessage| { &m.gateway_metadata },
                    |m: &mut DeduplicatedUplinkMessage| { &mut m.gateway_metadata },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "server_time",
                    |m: &DeduplicatedUplinkMessage| { &m.server_time },
                    |m: &mut DeduplicatedUplinkMessage| { &mut m.server_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DownlinkMessage>>(
                    "response_template",
                    |m: &DeduplicatedUplinkMessage| { &m.response_template },
                    |m: &mut DeduplicatedUplinkMessage| { &mut m.response_template },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::trace::Trace>>(
                    "trace",
                    |m: &DeduplicatedUplinkMessage| { &m.trace },
                    |m: &mut DeduplicatedUplinkMessage| { &mut m.trace },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeduplicatedUplinkMessage>(
                    "DeduplicatedUplinkMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeduplicatedUplinkMessage {
        static mut instance: ::protobuf::lazy::Lazy<DeduplicatedUplinkMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeduplicatedUplinkMessage,
        };
        unsafe {
            instance.get(DeduplicatedUplinkMessage::new)
        }
    }
}

impl ::protobuf::Clear for DeduplicatedUplinkMessage {
    fn clear(&mut self) {
        self.payload.clear();
        self.message.clear();
        self.dev_eui.clear();
        self.app_eui.clear();
        self.app_id.clear();
        self.dev_id.clear();
        self.protocol_metadata.clear();
        self.gateway_metadata.clear();
        self.server_time = 0;
        self.response_template.clear();
        self.trace.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeduplicatedUplinkMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeduplicatedUplinkMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeviceActivationRequest {
    // message fields
    pub payload: ::std::vec::Vec<u8>,
    pub message: ::protobuf::SingularPtrField<super::protocol::Message>,
    pub dev_eui: ::std::vec::Vec<u8>,
    pub app_eui: ::std::vec::Vec<u8>,
    pub protocol_metadata: ::protobuf::SingularPtrField<super::protocol::RxMetadata>,
    pub gateway_metadata: ::protobuf::SingularPtrField<super::gateway::RxMetadata>,
    pub activation_metadata: ::protobuf::SingularPtrField<super::protocol::ActivationMetadata>,
    pub downlink_options: ::protobuf::RepeatedField<DownlinkOption>,
    pub trace: ::protobuf::SingularPtrField<super::trace::Trace>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeviceActivationRequest {
    fn default() -> &'a DeviceActivationRequest {
        <DeviceActivationRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeviceActivationRequest {
    pub fn new() -> DeviceActivationRequest {
        ::std::default::Default::default()
    }

    // bytes payload = 1;


    pub fn get_payload(&self) -> &[u8] {
        &self.payload
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payload
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payload, ::std::vec::Vec::new())
    }

    // .protocol.Message message = 2;


    pub fn get_message(&self) -> &super::protocol::Message {
        self.message.as_ref().unwrap_or_else(|| super::protocol::Message::default_instance())
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: super::protocol::Message) {
        self.message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut super::protocol::Message {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> super::protocol::Message {
        self.message.take().unwrap_or_else(|| super::protocol::Message::new())
    }

    // bytes dev_eui = 11;


    pub fn get_dev_eui(&self) -> &[u8] {
        &self.dev_eui
    }
    pub fn clear_dev_eui(&mut self) {
        self.dev_eui.clear();
    }

    // Param is passed by value, moved
    pub fn set_dev_eui(&mut self, v: ::std::vec::Vec<u8>) {
        self.dev_eui = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dev_eui(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.dev_eui
    }

    // Take field
    pub fn take_dev_eui(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.dev_eui, ::std::vec::Vec::new())
    }

    // bytes app_eui = 12;


    pub fn get_app_eui(&self) -> &[u8] {
        &self.app_eui
    }
    pub fn clear_app_eui(&mut self) {
        self.app_eui.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_eui(&mut self, v: ::std::vec::Vec<u8>) {
        self.app_eui = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_eui(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.app_eui
    }

    // Take field
    pub fn take_app_eui(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.app_eui, ::std::vec::Vec::new())
    }

    // .protocol.RxMetadata protocol_metadata = 21;


    pub fn get_protocol_metadata(&self) -> &super::protocol::RxMetadata {
        self.protocol_metadata.as_ref().unwrap_or_else(|| super::protocol::RxMetadata::default_instance())
    }
    pub fn clear_protocol_metadata(&mut self) {
        self.protocol_metadata.clear();
    }

    pub fn has_protocol_metadata(&self) -> bool {
        self.protocol_metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_metadata(&mut self, v: super::protocol::RxMetadata) {
        self.protocol_metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocol_metadata(&mut self) -> &mut super::protocol::RxMetadata {
        if self.protocol_metadata.is_none() {
            self.protocol_metadata.set_default();
        }
        self.protocol_metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_protocol_metadata(&mut self) -> super::protocol::RxMetadata {
        self.protocol_metadata.take().unwrap_or_else(|| super::protocol::RxMetadata::new())
    }

    // .gateway.RxMetadata gateway_metadata = 22;


    pub fn get_gateway_metadata(&self) -> &super::gateway::RxMetadata {
        self.gateway_metadata.as_ref().unwrap_or_else(|| super::gateway::RxMetadata::default_instance())
    }
    pub fn clear_gateway_metadata(&mut self) {
        self.gateway_metadata.clear();
    }

    pub fn has_gateway_metadata(&self) -> bool {
        self.gateway_metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gateway_metadata(&mut self, v: super::gateway::RxMetadata) {
        self.gateway_metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gateway_metadata(&mut self) -> &mut super::gateway::RxMetadata {
        if self.gateway_metadata.is_none() {
            self.gateway_metadata.set_default();
        }
        self.gateway_metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_gateway_metadata(&mut self) -> super::gateway::RxMetadata {
        self.gateway_metadata.take().unwrap_or_else(|| super::gateway::RxMetadata::new())
    }

    // .protocol.ActivationMetadata activation_metadata = 23;


    pub fn get_activation_metadata(&self) -> &super::protocol::ActivationMetadata {
        self.activation_metadata.as_ref().unwrap_or_else(|| super::protocol::ActivationMetadata::default_instance())
    }
    pub fn clear_activation_metadata(&mut self) {
        self.activation_metadata.clear();
    }

    pub fn has_activation_metadata(&self) -> bool {
        self.activation_metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_activation_metadata(&mut self, v: super::protocol::ActivationMetadata) {
        self.activation_metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_activation_metadata(&mut self) -> &mut super::protocol::ActivationMetadata {
        if self.activation_metadata.is_none() {
            self.activation_metadata.set_default();
        }
        self.activation_metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_activation_metadata(&mut self) -> super::protocol::ActivationMetadata {
        self.activation_metadata.take().unwrap_or_else(|| super::protocol::ActivationMetadata::new())
    }

    // repeated .broker.DownlinkOption downlink_options = 31;


    pub fn get_downlink_options(&self) -> &[DownlinkOption] {
        &self.downlink_options
    }
    pub fn clear_downlink_options(&mut self) {
        self.downlink_options.clear();
    }

    // Param is passed by value, moved
    pub fn set_downlink_options(&mut self, v: ::protobuf::RepeatedField<DownlinkOption>) {
        self.downlink_options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_downlink_options(&mut self) -> &mut ::protobuf::RepeatedField<DownlinkOption> {
        &mut self.downlink_options
    }

    // Take field
    pub fn take_downlink_options(&mut self) -> ::protobuf::RepeatedField<DownlinkOption> {
        ::std::mem::replace(&mut self.downlink_options, ::protobuf::RepeatedField::new())
    }

    // .trace.Trace trace = 41;


    pub fn get_trace(&self) -> &super::trace::Trace {
        self.trace.as_ref().unwrap_or_else(|| super::trace::Trace::default_instance())
    }
    pub fn clear_trace(&mut self) {
        self.trace.clear();
    }

    pub fn has_trace(&self) -> bool {
        self.trace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trace(&mut self, v: super::trace::Trace) {
        self.trace = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trace(&mut self) -> &mut super::trace::Trace {
        if self.trace.is_none() {
            self.trace.set_default();
        }
        self.trace.as_mut().unwrap()
    }

    // Take field
    pub fn take_trace(&mut self) -> super::trace::Trace {
        self.trace.take().unwrap_or_else(|| super::trace::Trace::new())
    }
}

impl ::protobuf::Message for DeviceActivationRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.message {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.protocol_metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.gateway_metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.activation_metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.downlink_options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.trace {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payload)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.dev_eui)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.app_eui)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.protocol_metadata)?;
                },
                22 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.gateway_metadata)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.activation_metadata)?;
                },
                31 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.downlink_options)?;
                },
                41 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.trace)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.payload);
        }
        if let Some(ref v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.dev_eui.is_empty() {
            my_size += ::protobuf::rt::bytes_size(11, &self.dev_eui);
        }
        if !self.app_eui.is_empty() {
            my_size += ::protobuf::rt::bytes_size(12, &self.app_eui);
        }
        if let Some(ref v) = self.protocol_metadata.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.gateway_metadata.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.activation_metadata.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.downlink_options {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.trace.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.payload.is_empty() {
            os.write_bytes(1, &self.payload)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.dev_eui.is_empty() {
            os.write_bytes(11, &self.dev_eui)?;
        }
        if !self.app_eui.is_empty() {
            os.write_bytes(12, &self.app_eui)?;
        }
        if let Some(ref v) = self.protocol_metadata.as_ref() {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.gateway_metadata.as_ref() {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.activation_metadata.as_ref() {
            os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.downlink_options {
            os.write_tag(31, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.trace.as_ref() {
            os.write_tag(41, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeviceActivationRequest {
        DeviceActivationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payload",
                    |m: &DeviceActivationRequest| { &m.payload },
                    |m: &mut DeviceActivationRequest| { &mut m.payload },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::protocol::Message>>(
                    "message",
                    |m: &DeviceActivationRequest| { &m.message },
                    |m: &mut DeviceActivationRequest| { &mut m.message },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "dev_eui",
                    |m: &DeviceActivationRequest| { &m.dev_eui },
                    |m: &mut DeviceActivationRequest| { &mut m.dev_eui },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "app_eui",
                    |m: &DeviceActivationRequest| { &m.app_eui },
                    |m: &mut DeviceActivationRequest| { &mut m.app_eui },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::protocol::RxMetadata>>(
                    "protocol_metadata",
                    |m: &DeviceActivationRequest| { &m.protocol_metadata },
                    |m: &mut DeviceActivationRequest| { &mut m.protocol_metadata },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::gateway::RxMetadata>>(
                    "gateway_metadata",
                    |m: &DeviceActivationRequest| { &m.gateway_metadata },
                    |m: &mut DeviceActivationRequest| { &mut m.gateway_metadata },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::protocol::ActivationMetadata>>(
                    "activation_metadata",
                    |m: &DeviceActivationRequest| { &m.activation_metadata },
                    |m: &mut DeviceActivationRequest| { &mut m.activation_metadata },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DownlinkOption>>(
                    "downlink_options",
                    |m: &DeviceActivationRequest| { &m.downlink_options },
                    |m: &mut DeviceActivationRequest| { &mut m.downlink_options },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::trace::Trace>>(
                    "trace",
                    |m: &DeviceActivationRequest| { &m.trace },
                    |m: &mut DeviceActivationRequest| { &mut m.trace },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeviceActivationRequest>(
                    "DeviceActivationRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeviceActivationRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeviceActivationRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeviceActivationRequest,
        };
        unsafe {
            instance.get(DeviceActivationRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeviceActivationRequest {
    fn clear(&mut self) {
        self.payload.clear();
        self.message.clear();
        self.dev_eui.clear();
        self.app_eui.clear();
        self.protocol_metadata.clear();
        self.gateway_metadata.clear();
        self.activation_metadata.clear();
        self.downlink_options.clear();
        self.trace.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceActivationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceActivationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeduplicatedDeviceActivationRequest {
    // message fields
    pub payload: ::std::vec::Vec<u8>,
    pub message: ::protobuf::SingularPtrField<super::protocol::Message>,
    pub dev_eui: ::std::vec::Vec<u8>,
    pub app_eui: ::std::vec::Vec<u8>,
    pub app_id: ::std::string::String,
    pub dev_id: ::std::string::String,
    pub protocol_metadata: ::protobuf::SingularPtrField<super::protocol::RxMetadata>,
    pub gateway_metadata: ::protobuf::RepeatedField<super::gateway::RxMetadata>,
    pub activation_metadata: ::protobuf::SingularPtrField<super::protocol::ActivationMetadata>,
    pub server_time: i64,
    pub response_template: ::protobuf::SingularPtrField<DeviceActivationResponse>,
    pub trace: ::protobuf::SingularPtrField<super::trace::Trace>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeduplicatedDeviceActivationRequest {
    fn default() -> &'a DeduplicatedDeviceActivationRequest {
        <DeduplicatedDeviceActivationRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeduplicatedDeviceActivationRequest {
    pub fn new() -> DeduplicatedDeviceActivationRequest {
        ::std::default::Default::default()
    }

    // bytes payload = 1;


    pub fn get_payload(&self) -> &[u8] {
        &self.payload
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payload
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payload, ::std::vec::Vec::new())
    }

    // .protocol.Message message = 2;


    pub fn get_message(&self) -> &super::protocol::Message {
        self.message.as_ref().unwrap_or_else(|| super::protocol::Message::default_instance())
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: super::protocol::Message) {
        self.message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut super::protocol::Message {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> super::protocol::Message {
        self.message.take().unwrap_or_else(|| super::protocol::Message::new())
    }

    // bytes dev_eui = 11;


    pub fn get_dev_eui(&self) -> &[u8] {
        &self.dev_eui
    }
    pub fn clear_dev_eui(&mut self) {
        self.dev_eui.clear();
    }

    // Param is passed by value, moved
    pub fn set_dev_eui(&mut self, v: ::std::vec::Vec<u8>) {
        self.dev_eui = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dev_eui(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.dev_eui
    }

    // Take field
    pub fn take_dev_eui(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.dev_eui, ::std::vec::Vec::new())
    }

    // bytes app_eui = 12;


    pub fn get_app_eui(&self) -> &[u8] {
        &self.app_eui
    }
    pub fn clear_app_eui(&mut self) {
        self.app_eui.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_eui(&mut self, v: ::std::vec::Vec<u8>) {
        self.app_eui = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_eui(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.app_eui
    }

    // Take field
    pub fn take_app_eui(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.app_eui, ::std::vec::Vec::new())
    }

    // string app_id = 13;


    pub fn get_app_id(&self) -> &str {
        &self.app_id
    }
    pub fn clear_app_id(&mut self) {
        self.app_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: ::std::string::String) {
        self.app_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_id(&mut self) -> &mut ::std::string::String {
        &mut self.app_id
    }

    // Take field
    pub fn take_app_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.app_id, ::std::string::String::new())
    }

    // string dev_id = 14;


    pub fn get_dev_id(&self) -> &str {
        &self.dev_id
    }
    pub fn clear_dev_id(&mut self) {
        self.dev_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_dev_id(&mut self, v: ::std::string::String) {
        self.dev_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dev_id(&mut self) -> &mut ::std::string::String {
        &mut self.dev_id
    }

    // Take field
    pub fn take_dev_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dev_id, ::std::string::String::new())
    }

    // .protocol.RxMetadata protocol_metadata = 21;


    pub fn get_protocol_metadata(&self) -> &super::protocol::RxMetadata {
        self.protocol_metadata.as_ref().unwrap_or_else(|| super::protocol::RxMetadata::default_instance())
    }
    pub fn clear_protocol_metadata(&mut self) {
        self.protocol_metadata.clear();
    }

    pub fn has_protocol_metadata(&self) -> bool {
        self.protocol_metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_metadata(&mut self, v: super::protocol::RxMetadata) {
        self.protocol_metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocol_metadata(&mut self) -> &mut super::protocol::RxMetadata {
        if self.protocol_metadata.is_none() {
            self.protocol_metadata.set_default();
        }
        self.protocol_metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_protocol_metadata(&mut self) -> super::protocol::RxMetadata {
        self.protocol_metadata.take().unwrap_or_else(|| super::protocol::RxMetadata::new())
    }

    // repeated .gateway.RxMetadata gateway_metadata = 22;


    pub fn get_gateway_metadata(&self) -> &[super::gateway::RxMetadata] {
        &self.gateway_metadata
    }
    pub fn clear_gateway_metadata(&mut self) {
        self.gateway_metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_gateway_metadata(&mut self, v: ::protobuf::RepeatedField<super::gateway::RxMetadata>) {
        self.gateway_metadata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_gateway_metadata(&mut self) -> &mut ::protobuf::RepeatedField<super::gateway::RxMetadata> {
        &mut self.gateway_metadata
    }

    // Take field
    pub fn take_gateway_metadata(&mut self) -> ::protobuf::RepeatedField<super::gateway::RxMetadata> {
        ::std::mem::replace(&mut self.gateway_metadata, ::protobuf::RepeatedField::new())
    }

    // .protocol.ActivationMetadata activation_metadata = 23;


    pub fn get_activation_metadata(&self) -> &super::protocol::ActivationMetadata {
        self.activation_metadata.as_ref().unwrap_or_else(|| super::protocol::ActivationMetadata::default_instance())
    }
    pub fn clear_activation_metadata(&mut self) {
        self.activation_metadata.clear();
    }

    pub fn has_activation_metadata(&self) -> bool {
        self.activation_metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_activation_metadata(&mut self, v: super::protocol::ActivationMetadata) {
        self.activation_metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_activation_metadata(&mut self) -> &mut super::protocol::ActivationMetadata {
        if self.activation_metadata.is_none() {
            self.activation_metadata.set_default();
        }
        self.activation_metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_activation_metadata(&mut self) -> super::protocol::ActivationMetadata {
        self.activation_metadata.take().unwrap_or_else(|| super::protocol::ActivationMetadata::new())
    }

    // int64 server_time = 24;


    pub fn get_server_time(&self) -> i64 {
        self.server_time
    }
    pub fn clear_server_time(&mut self) {
        self.server_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_server_time(&mut self, v: i64) {
        self.server_time = v;
    }

    // .broker.DeviceActivationResponse response_template = 31;


    pub fn get_response_template(&self) -> &DeviceActivationResponse {
        self.response_template.as_ref().unwrap_or_else(|| DeviceActivationResponse::default_instance())
    }
    pub fn clear_response_template(&mut self) {
        self.response_template.clear();
    }

    pub fn has_response_template(&self) -> bool {
        self.response_template.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response_template(&mut self, v: DeviceActivationResponse) {
        self.response_template = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_response_template(&mut self) -> &mut DeviceActivationResponse {
        if self.response_template.is_none() {
            self.response_template.set_default();
        }
        self.response_template.as_mut().unwrap()
    }

    // Take field
    pub fn take_response_template(&mut self) -> DeviceActivationResponse {
        self.response_template.take().unwrap_or_else(|| DeviceActivationResponse::new())
    }

    // .trace.Trace trace = 41;


    pub fn get_trace(&self) -> &super::trace::Trace {
        self.trace.as_ref().unwrap_or_else(|| super::trace::Trace::default_instance())
    }
    pub fn clear_trace(&mut self) {
        self.trace.clear();
    }

    pub fn has_trace(&self) -> bool {
        self.trace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trace(&mut self, v: super::trace::Trace) {
        self.trace = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trace(&mut self) -> &mut super::trace::Trace {
        if self.trace.is_none() {
            self.trace.set_default();
        }
        self.trace.as_mut().unwrap()
    }

    // Take field
    pub fn take_trace(&mut self) -> super::trace::Trace {
        self.trace.take().unwrap_or_else(|| super::trace::Trace::new())
    }
}

impl ::protobuf::Message for DeduplicatedDeviceActivationRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.message {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.protocol_metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.gateway_metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.activation_metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.response_template {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.trace {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payload)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.dev_eui)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.app_eui)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.app_id)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dev_id)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.protocol_metadata)?;
                },
                22 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.gateway_metadata)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.activation_metadata)?;
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.server_time = tmp;
                },
                31 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.response_template)?;
                },
                41 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.trace)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.payload);
        }
        if let Some(ref v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.dev_eui.is_empty() {
            my_size += ::protobuf::rt::bytes_size(11, &self.dev_eui);
        }
        if !self.app_eui.is_empty() {
            my_size += ::protobuf::rt::bytes_size(12, &self.app_eui);
        }
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.app_id);
        }
        if !self.dev_id.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.dev_id);
        }
        if let Some(ref v) = self.protocol_metadata.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.gateway_metadata {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.activation_metadata.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.server_time != 0 {
            my_size += ::protobuf::rt::value_size(24, self.server_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.response_template.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.trace.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.payload.is_empty() {
            os.write_bytes(1, &self.payload)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.dev_eui.is_empty() {
            os.write_bytes(11, &self.dev_eui)?;
        }
        if !self.app_eui.is_empty() {
            os.write_bytes(12, &self.app_eui)?;
        }
        if !self.app_id.is_empty() {
            os.write_string(13, &self.app_id)?;
        }
        if !self.dev_id.is_empty() {
            os.write_string(14, &self.dev_id)?;
        }
        if let Some(ref v) = self.protocol_metadata.as_ref() {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.gateway_metadata {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.activation_metadata.as_ref() {
            os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.server_time != 0 {
            os.write_int64(24, self.server_time)?;
        }
        if let Some(ref v) = self.response_template.as_ref() {
            os.write_tag(31, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.trace.as_ref() {
            os.write_tag(41, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeduplicatedDeviceActivationRequest {
        DeduplicatedDeviceActivationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payload",
                    |m: &DeduplicatedDeviceActivationRequest| { &m.payload },
                    |m: &mut DeduplicatedDeviceActivationRequest| { &mut m.payload },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::protocol::Message>>(
                    "message",
                    |m: &DeduplicatedDeviceActivationRequest| { &m.message },
                    |m: &mut DeduplicatedDeviceActivationRequest| { &mut m.message },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "dev_eui",
                    |m: &DeduplicatedDeviceActivationRequest| { &m.dev_eui },
                    |m: &mut DeduplicatedDeviceActivationRequest| { &mut m.dev_eui },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "app_eui",
                    |m: &DeduplicatedDeviceActivationRequest| { &m.app_eui },
                    |m: &mut DeduplicatedDeviceActivationRequest| { &mut m.app_eui },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "app_id",
                    |m: &DeduplicatedDeviceActivationRequest| { &m.app_id },
                    |m: &mut DeduplicatedDeviceActivationRequest| { &mut m.app_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dev_id",
                    |m: &DeduplicatedDeviceActivationRequest| { &m.dev_id },
                    |m: &mut DeduplicatedDeviceActivationRequest| { &mut m.dev_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::protocol::RxMetadata>>(
                    "protocol_metadata",
                    |m: &DeduplicatedDeviceActivationRequest| { &m.protocol_metadata },
                    |m: &mut DeduplicatedDeviceActivationRequest| { &mut m.protocol_metadata },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::gateway::RxMetadata>>(
                    "gateway_metadata",
                    |m: &DeduplicatedDeviceActivationRequest| { &m.gateway_metadata },
                    |m: &mut DeduplicatedDeviceActivationRequest| { &mut m.gateway_metadata },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::protocol::ActivationMetadata>>(
                    "activation_metadata",
                    |m: &DeduplicatedDeviceActivationRequest| { &m.activation_metadata },
                    |m: &mut DeduplicatedDeviceActivationRequest| { &mut m.activation_metadata },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "server_time",
                    |m: &DeduplicatedDeviceActivationRequest| { &m.server_time },
                    |m: &mut DeduplicatedDeviceActivationRequest| { &mut m.server_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeviceActivationResponse>>(
                    "response_template",
                    |m: &DeduplicatedDeviceActivationRequest| { &m.response_template },
                    |m: &mut DeduplicatedDeviceActivationRequest| { &mut m.response_template },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::trace::Trace>>(
                    "trace",
                    |m: &DeduplicatedDeviceActivationRequest| { &m.trace },
                    |m: &mut DeduplicatedDeviceActivationRequest| { &mut m.trace },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeduplicatedDeviceActivationRequest>(
                    "DeduplicatedDeviceActivationRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeduplicatedDeviceActivationRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeduplicatedDeviceActivationRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeduplicatedDeviceActivationRequest,
        };
        unsafe {
            instance.get(DeduplicatedDeviceActivationRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeduplicatedDeviceActivationRequest {
    fn clear(&mut self) {
        self.payload.clear();
        self.message.clear();
        self.dev_eui.clear();
        self.app_eui.clear();
        self.app_id.clear();
        self.dev_id.clear();
        self.protocol_metadata.clear();
        self.gateway_metadata.clear();
        self.activation_metadata.clear();
        self.server_time = 0;
        self.response_template.clear();
        self.trace.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeduplicatedDeviceActivationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeduplicatedDeviceActivationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActivationChallengeRequest {
    // message fields
    pub payload: ::std::vec::Vec<u8>,
    pub message: ::protobuf::SingularPtrField<super::protocol::Message>,
    pub dev_eui: ::std::vec::Vec<u8>,
    pub app_eui: ::std::vec::Vec<u8>,
    pub app_id: ::std::string::String,
    pub dev_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActivationChallengeRequest {
    fn default() -> &'a ActivationChallengeRequest {
        <ActivationChallengeRequest as ::protobuf::Message>::default_instance()
    }
}

impl ActivationChallengeRequest {
    pub fn new() -> ActivationChallengeRequest {
        ::std::default::Default::default()
    }

    // bytes payload = 1;


    pub fn get_payload(&self) -> &[u8] {
        &self.payload
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payload
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payload, ::std::vec::Vec::new())
    }

    // .protocol.Message message = 2;


    pub fn get_message(&self) -> &super::protocol::Message {
        self.message.as_ref().unwrap_or_else(|| super::protocol::Message::default_instance())
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: super::protocol::Message) {
        self.message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut super::protocol::Message {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> super::protocol::Message {
        self.message.take().unwrap_or_else(|| super::protocol::Message::new())
    }

    // bytes dev_eui = 11;


    pub fn get_dev_eui(&self) -> &[u8] {
        &self.dev_eui
    }
    pub fn clear_dev_eui(&mut self) {
        self.dev_eui.clear();
    }

    // Param is passed by value, moved
    pub fn set_dev_eui(&mut self, v: ::std::vec::Vec<u8>) {
        self.dev_eui = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dev_eui(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.dev_eui
    }

    // Take field
    pub fn take_dev_eui(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.dev_eui, ::std::vec::Vec::new())
    }

    // bytes app_eui = 12;


    pub fn get_app_eui(&self) -> &[u8] {
        &self.app_eui
    }
    pub fn clear_app_eui(&mut self) {
        self.app_eui.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_eui(&mut self, v: ::std::vec::Vec<u8>) {
        self.app_eui = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_eui(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.app_eui
    }

    // Take field
    pub fn take_app_eui(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.app_eui, ::std::vec::Vec::new())
    }

    // string app_id = 13;


    pub fn get_app_id(&self) -> &str {
        &self.app_id
    }
    pub fn clear_app_id(&mut self) {
        self.app_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: ::std::string::String) {
        self.app_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_id(&mut self) -> &mut ::std::string::String {
        &mut self.app_id
    }

    // Take field
    pub fn take_app_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.app_id, ::std::string::String::new())
    }

    // string dev_id = 14;


    pub fn get_dev_id(&self) -> &str {
        &self.dev_id
    }
    pub fn clear_dev_id(&mut self) {
        self.dev_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_dev_id(&mut self, v: ::std::string::String) {
        self.dev_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dev_id(&mut self) -> &mut ::std::string::String {
        &mut self.dev_id
    }

    // Take field
    pub fn take_dev_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dev_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ActivationChallengeRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.message {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payload)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.dev_eui)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.app_eui)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.app_id)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dev_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.payload);
        }
        if let Some(ref v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.dev_eui.is_empty() {
            my_size += ::protobuf::rt::bytes_size(11, &self.dev_eui);
        }
        if !self.app_eui.is_empty() {
            my_size += ::protobuf::rt::bytes_size(12, &self.app_eui);
        }
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.app_id);
        }
        if !self.dev_id.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.dev_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.payload.is_empty() {
            os.write_bytes(1, &self.payload)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.dev_eui.is_empty() {
            os.write_bytes(11, &self.dev_eui)?;
        }
        if !self.app_eui.is_empty() {
            os.write_bytes(12, &self.app_eui)?;
        }
        if !self.app_id.is_empty() {
            os.write_string(13, &self.app_id)?;
        }
        if !self.dev_id.is_empty() {
            os.write_string(14, &self.dev_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActivationChallengeRequest {
        ActivationChallengeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payload",
                    |m: &ActivationChallengeRequest| { &m.payload },
                    |m: &mut ActivationChallengeRequest| { &mut m.payload },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::protocol::Message>>(
                    "message",
                    |m: &ActivationChallengeRequest| { &m.message },
                    |m: &mut ActivationChallengeRequest| { &mut m.message },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "dev_eui",
                    |m: &ActivationChallengeRequest| { &m.dev_eui },
                    |m: &mut ActivationChallengeRequest| { &mut m.dev_eui },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "app_eui",
                    |m: &ActivationChallengeRequest| { &m.app_eui },
                    |m: &mut ActivationChallengeRequest| { &mut m.app_eui },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "app_id",
                    |m: &ActivationChallengeRequest| { &m.app_id },
                    |m: &mut ActivationChallengeRequest| { &mut m.app_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dev_id",
                    |m: &ActivationChallengeRequest| { &m.dev_id },
                    |m: &mut ActivationChallengeRequest| { &mut m.dev_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ActivationChallengeRequest>(
                    "ActivationChallengeRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActivationChallengeRequest {
        static mut instance: ::protobuf::lazy::Lazy<ActivationChallengeRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ActivationChallengeRequest,
        };
        unsafe {
            instance.get(ActivationChallengeRequest::new)
        }
    }
}

impl ::protobuf::Clear for ActivationChallengeRequest {
    fn clear(&mut self) {
        self.payload.clear();
        self.message.clear();
        self.dev_eui.clear();
        self.app_eui.clear();
        self.app_id.clear();
        self.dev_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActivationChallengeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActivationChallengeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActivationChallengeResponse {
    // message fields
    pub payload: ::std::vec::Vec<u8>,
    pub message: ::protobuf::SingularPtrField<super::protocol::Message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActivationChallengeResponse {
    fn default() -> &'a ActivationChallengeResponse {
        <ActivationChallengeResponse as ::protobuf::Message>::default_instance()
    }
}

impl ActivationChallengeResponse {
    pub fn new() -> ActivationChallengeResponse {
        ::std::default::Default::default()
    }

    // bytes payload = 1;


    pub fn get_payload(&self) -> &[u8] {
        &self.payload
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payload
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payload, ::std::vec::Vec::new())
    }

    // .protocol.Message message = 2;


    pub fn get_message(&self) -> &super::protocol::Message {
        self.message.as_ref().unwrap_or_else(|| super::protocol::Message::default_instance())
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: super::protocol::Message) {
        self.message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut super::protocol::Message {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> super::protocol::Message {
        self.message.take().unwrap_or_else(|| super::protocol::Message::new())
    }
}

impl ::protobuf::Message for ActivationChallengeResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.message {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payload)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.payload);
        }
        if let Some(ref v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.payload.is_empty() {
            os.write_bytes(1, &self.payload)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActivationChallengeResponse {
        ActivationChallengeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payload",
                    |m: &ActivationChallengeResponse| { &m.payload },
                    |m: &mut ActivationChallengeResponse| { &mut m.payload },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::protocol::Message>>(
                    "message",
                    |m: &ActivationChallengeResponse| { &m.message },
                    |m: &mut ActivationChallengeResponse| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ActivationChallengeResponse>(
                    "ActivationChallengeResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActivationChallengeResponse {
        static mut instance: ::protobuf::lazy::Lazy<ActivationChallengeResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ActivationChallengeResponse,
        };
        unsafe {
            instance.get(ActivationChallengeResponse::new)
        }
    }
}

impl ::protobuf::Clear for ActivationChallengeResponse {
    fn clear(&mut self) {
        self.payload.clear();
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActivationChallengeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActivationChallengeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeRequest {
    fn default() -> &'a SubscribeRequest {
        <SubscribeRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeRequest {
    pub fn new() -> SubscribeRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SubscribeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeRequest {
        SubscribeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SubscribeRequest>(
                    "SubscribeRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SubscribeRequest {
        static mut instance: ::protobuf::lazy::Lazy<SubscribeRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SubscribeRequest,
        };
        unsafe {
            instance.get(SubscribeRequest::new)
        }
    }
}

impl ::protobuf::Clear for SubscribeRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatusRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatusRequest {
    fn default() -> &'a StatusRequest {
        <StatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl StatusRequest {
    pub fn new() -> StatusRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StatusRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatusRequest {
        StatusRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<StatusRequest>(
                    "StatusRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StatusRequest {
        static mut instance: ::protobuf::lazy::Lazy<StatusRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StatusRequest,
        };
        unsafe {
            instance.get(StatusRequest::new)
        }
    }
}

impl ::protobuf::Clear for StatusRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Status {
    // message fields
    pub system: ::protobuf::SingularPtrField<super::api::SystemStats>,
    pub component: ::protobuf::SingularPtrField<super::api::ComponentStats>,
    pub uplink: ::protobuf::SingularPtrField<super::api::Rates>,
    pub uplink_unique: ::protobuf::SingularPtrField<super::api::Rates>,
    pub downlink: ::protobuf::SingularPtrField<super::api::Rates>,
    pub activations: ::protobuf::SingularPtrField<super::api::Rates>,
    pub activations_unique: ::protobuf::SingularPtrField<super::api::Rates>,
    pub deduplication: ::protobuf::SingularPtrField<super::api::Percentiles>,
    pub connected_routers: u32,
    pub connected_handlers: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Status {
    fn default() -> &'a Status {
        <Status as ::protobuf::Message>::default_instance()
    }
}

impl Status {
    pub fn new() -> Status {
        ::std::default::Default::default()
    }

    // .api.SystemStats system = 1;


    pub fn get_system(&self) -> &super::api::SystemStats {
        self.system.as_ref().unwrap_or_else(|| super::api::SystemStats::default_instance())
    }
    pub fn clear_system(&mut self) {
        self.system.clear();
    }

    pub fn has_system(&self) -> bool {
        self.system.is_some()
    }

    // Param is passed by value, moved
    pub fn set_system(&mut self, v: super::api::SystemStats) {
        self.system = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_system(&mut self) -> &mut super::api::SystemStats {
        if self.system.is_none() {
            self.system.set_default();
        }
        self.system.as_mut().unwrap()
    }

    // Take field
    pub fn take_system(&mut self) -> super::api::SystemStats {
        self.system.take().unwrap_or_else(|| super::api::SystemStats::new())
    }

    // .api.ComponentStats component = 2;


    pub fn get_component(&self) -> &super::api::ComponentStats {
        self.component.as_ref().unwrap_or_else(|| super::api::ComponentStats::default_instance())
    }
    pub fn clear_component(&mut self) {
        self.component.clear();
    }

    pub fn has_component(&self) -> bool {
        self.component.is_some()
    }

    // Param is passed by value, moved
    pub fn set_component(&mut self, v: super::api::ComponentStats) {
        self.component = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_component(&mut self) -> &mut super::api::ComponentStats {
        if self.component.is_none() {
            self.component.set_default();
        }
        self.component.as_mut().unwrap()
    }

    // Take field
    pub fn take_component(&mut self) -> super::api::ComponentStats {
        self.component.take().unwrap_or_else(|| super::api::ComponentStats::new())
    }

    // .api.Rates uplink = 11;


    pub fn get_uplink(&self) -> &super::api::Rates {
        self.uplink.as_ref().unwrap_or_else(|| super::api::Rates::default_instance())
    }
    pub fn clear_uplink(&mut self) {
        self.uplink.clear();
    }

    pub fn has_uplink(&self) -> bool {
        self.uplink.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uplink(&mut self, v: super::api::Rates) {
        self.uplink = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uplink(&mut self) -> &mut super::api::Rates {
        if self.uplink.is_none() {
            self.uplink.set_default();
        }
        self.uplink.as_mut().unwrap()
    }

    // Take field
    pub fn take_uplink(&mut self) -> super::api::Rates {
        self.uplink.take().unwrap_or_else(|| super::api::Rates::new())
    }

    // .api.Rates uplink_unique = 12;


    pub fn get_uplink_unique(&self) -> &super::api::Rates {
        self.uplink_unique.as_ref().unwrap_or_else(|| super::api::Rates::default_instance())
    }
    pub fn clear_uplink_unique(&mut self) {
        self.uplink_unique.clear();
    }

    pub fn has_uplink_unique(&self) -> bool {
        self.uplink_unique.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uplink_unique(&mut self, v: super::api::Rates) {
        self.uplink_unique = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uplink_unique(&mut self) -> &mut super::api::Rates {
        if self.uplink_unique.is_none() {
            self.uplink_unique.set_default();
        }
        self.uplink_unique.as_mut().unwrap()
    }

    // Take field
    pub fn take_uplink_unique(&mut self) -> super::api::Rates {
        self.uplink_unique.take().unwrap_or_else(|| super::api::Rates::new())
    }

    // .api.Rates downlink = 13;


    pub fn get_downlink(&self) -> &super::api::Rates {
        self.downlink.as_ref().unwrap_or_else(|| super::api::Rates::default_instance())
    }
    pub fn clear_downlink(&mut self) {
        self.downlink.clear();
    }

    pub fn has_downlink(&self) -> bool {
        self.downlink.is_some()
    }

    // Param is passed by value, moved
    pub fn set_downlink(&mut self, v: super::api::Rates) {
        self.downlink = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_downlink(&mut self) -> &mut super::api::Rates {
        if self.downlink.is_none() {
            self.downlink.set_default();
        }
        self.downlink.as_mut().unwrap()
    }

    // Take field
    pub fn take_downlink(&mut self) -> super::api::Rates {
        self.downlink.take().unwrap_or_else(|| super::api::Rates::new())
    }

    // .api.Rates activations = 14;


    pub fn get_activations(&self) -> &super::api::Rates {
        self.activations.as_ref().unwrap_or_else(|| super::api::Rates::default_instance())
    }
    pub fn clear_activations(&mut self) {
        self.activations.clear();
    }

    pub fn has_activations(&self) -> bool {
        self.activations.is_some()
    }

    // Param is passed by value, moved
    pub fn set_activations(&mut self, v: super::api::Rates) {
        self.activations = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_activations(&mut self) -> &mut super::api::Rates {
        if self.activations.is_none() {
            self.activations.set_default();
        }
        self.activations.as_mut().unwrap()
    }

    // Take field
    pub fn take_activations(&mut self) -> super::api::Rates {
        self.activations.take().unwrap_or_else(|| super::api::Rates::new())
    }

    // .api.Rates activations_unique = 15;


    pub fn get_activations_unique(&self) -> &super::api::Rates {
        self.activations_unique.as_ref().unwrap_or_else(|| super::api::Rates::default_instance())
    }
    pub fn clear_activations_unique(&mut self) {
        self.activations_unique.clear();
    }

    pub fn has_activations_unique(&self) -> bool {
        self.activations_unique.is_some()
    }

    // Param is passed by value, moved
    pub fn set_activations_unique(&mut self, v: super::api::Rates) {
        self.activations_unique = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_activations_unique(&mut self) -> &mut super::api::Rates {
        if self.activations_unique.is_none() {
            self.activations_unique.set_default();
        }
        self.activations_unique.as_mut().unwrap()
    }

    // Take field
    pub fn take_activations_unique(&mut self) -> super::api::Rates {
        self.activations_unique.take().unwrap_or_else(|| super::api::Rates::new())
    }

    // .api.Percentiles deduplication = 16;


    pub fn get_deduplication(&self) -> &super::api::Percentiles {
        self.deduplication.as_ref().unwrap_or_else(|| super::api::Percentiles::default_instance())
    }
    pub fn clear_deduplication(&mut self) {
        self.deduplication.clear();
    }

    pub fn has_deduplication(&self) -> bool {
        self.deduplication.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deduplication(&mut self, v: super::api::Percentiles) {
        self.deduplication = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deduplication(&mut self) -> &mut super::api::Percentiles {
        if self.deduplication.is_none() {
            self.deduplication.set_default();
        }
        self.deduplication.as_mut().unwrap()
    }

    // Take field
    pub fn take_deduplication(&mut self) -> super::api::Percentiles {
        self.deduplication.take().unwrap_or_else(|| super::api::Percentiles::new())
    }

    // uint32 connected_routers = 21;


    pub fn get_connected_routers(&self) -> u32 {
        self.connected_routers
    }
    pub fn clear_connected_routers(&mut self) {
        self.connected_routers = 0;
    }

    // Param is passed by value, moved
    pub fn set_connected_routers(&mut self, v: u32) {
        self.connected_routers = v;
    }

    // uint32 connected_handlers = 22;


    pub fn get_connected_handlers(&self) -> u32 {
        self.connected_handlers
    }
    pub fn clear_connected_handlers(&mut self) {
        self.connected_handlers = 0;
    }

    // Param is passed by value, moved
    pub fn set_connected_handlers(&mut self, v: u32) {
        self.connected_handlers = v;
    }
}

impl ::protobuf::Message for Status {
    fn is_initialized(&self) -> bool {
        for v in &self.system {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.component {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.uplink {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.uplink_unique {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.downlink {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.activations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.activations_unique {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.deduplication {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.system)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.component)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.uplink)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.uplink_unique)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.downlink)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.activations)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.activations_unique)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.deduplication)?;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.connected_routers = tmp;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.connected_handlers = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.system.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.component.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.uplink.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.uplink_unique.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.downlink.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.activations.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.activations_unique.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.deduplication.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.connected_routers != 0 {
            my_size += ::protobuf::rt::value_size(21, self.connected_routers, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.connected_handlers != 0 {
            my_size += ::protobuf::rt::value_size(22, self.connected_handlers, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.system.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.component.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.uplink.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.uplink_unique.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.downlink.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.activations.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.activations_unique.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.deduplication.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.connected_routers != 0 {
            os.write_uint32(21, self.connected_routers)?;
        }
        if self.connected_handlers != 0 {
            os.write_uint32(22, self.connected_handlers)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Status {
        Status::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::api::SystemStats>>(
                    "system",
                    |m: &Status| { &m.system },
                    |m: &mut Status| { &mut m.system },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::api::ComponentStats>>(
                    "component",
                    |m: &Status| { &m.component },
                    |m: &mut Status| { &mut m.component },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::api::Rates>>(
                    "uplink",
                    |m: &Status| { &m.uplink },
                    |m: &mut Status| { &mut m.uplink },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::api::Rates>>(
                    "uplink_unique",
                    |m: &Status| { &m.uplink_unique },
                    |m: &mut Status| { &mut m.uplink_unique },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::api::Rates>>(
                    "downlink",
                    |m: &Status| { &m.downlink },
                    |m: &mut Status| { &mut m.downlink },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::api::Rates>>(
                    "activations",
                    |m: &Status| { &m.activations },
                    |m: &mut Status| { &mut m.activations },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::api::Rates>>(
                    "activations_unique",
                    |m: &Status| { &m.activations_unique },
                    |m: &mut Status| { &mut m.activations_unique },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::api::Percentiles>>(
                    "deduplication",
                    |m: &Status| { &m.deduplication },
                    |m: &mut Status| { &mut m.deduplication },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "connected_routers",
                    |m: &Status| { &m.connected_routers },
                    |m: &mut Status| { &mut m.connected_routers },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "connected_handlers",
                    |m: &Status| { &m.connected_handlers },
                    |m: &mut Status| { &mut m.connected_handlers },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Status>(
                    "Status",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Status {
        static mut instance: ::protobuf::lazy::Lazy<Status> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Status,
        };
        unsafe {
            instance.get(Status::new)
        }
    }
}

impl ::protobuf::Clear for Status {
    fn clear(&mut self) {
        self.system.clear();
        self.component.clear();
        self.uplink.clear();
        self.uplink_unique.clear();
        self.downlink.clear();
        self.activations.clear();
        self.activations_unique.clear();
        self.deduplication.clear();
        self.connected_routers = 0;
        self.connected_handlers = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Status {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Status {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ApplicationHandlerRegistration {
    // message fields
    pub app_id: ::std::string::String,
    pub handler_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ApplicationHandlerRegistration {
    fn default() -> &'a ApplicationHandlerRegistration {
        <ApplicationHandlerRegistration as ::protobuf::Message>::default_instance()
    }
}

impl ApplicationHandlerRegistration {
    pub fn new() -> ApplicationHandlerRegistration {
        ::std::default::Default::default()
    }

    // string app_id = 1;


    pub fn get_app_id(&self) -> &str {
        &self.app_id
    }
    pub fn clear_app_id(&mut self) {
        self.app_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: ::std::string::String) {
        self.app_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_id(&mut self) -> &mut ::std::string::String {
        &mut self.app_id
    }

    // Take field
    pub fn take_app_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.app_id, ::std::string::String::new())
    }

    // string handler_id = 2;


    pub fn get_handler_id(&self) -> &str {
        &self.handler_id
    }
    pub fn clear_handler_id(&mut self) {
        self.handler_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_handler_id(&mut self, v: ::std::string::String) {
        self.handler_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_handler_id(&mut self) -> &mut ::std::string::String {
        &mut self.handler_id
    }

    // Take field
    pub fn take_handler_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.handler_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ApplicationHandlerRegistration {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.app_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.handler_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.app_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.app_id);
        }
        if !self.handler_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.handler_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.app_id.is_empty() {
            os.write_string(1, &self.app_id)?;
        }
        if !self.handler_id.is_empty() {
            os.write_string(2, &self.handler_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ApplicationHandlerRegistration {
        ApplicationHandlerRegistration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "app_id",
                    |m: &ApplicationHandlerRegistration| { &m.app_id },
                    |m: &mut ApplicationHandlerRegistration| { &mut m.app_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "handler_id",
                    |m: &ApplicationHandlerRegistration| { &m.handler_id },
                    |m: &mut ApplicationHandlerRegistration| { &mut m.handler_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ApplicationHandlerRegistration>(
                    "ApplicationHandlerRegistration",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ApplicationHandlerRegistration {
        static mut instance: ::protobuf::lazy::Lazy<ApplicationHandlerRegistration> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ApplicationHandlerRegistration,
        };
        unsafe {
            instance.get(ApplicationHandlerRegistration::new)
        }
    }
}

impl ::protobuf::Clear for ApplicationHandlerRegistration {
    fn clear(&mut self) {
        self.app_id.clear();
        self.handler_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ApplicationHandlerRegistration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ApplicationHandlerRegistration {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n3github.com/TheThingsNetwork/api/broker/broker.proto\x12\x06broker\x1a\
    \x1bgoogle/protobuf/empty.proto\x1a-github.com/gogo/protobuf/gogoproto/g\
    ogo.proto\x1a)github.com/TheThingsNetwork/api/api.proto\x1a7github.com/T\
    heThingsNetwork/api/protocol/protocol.proto\x1a5github.com/TheThingsNetw\
    ork/api/gateway/gateway.proto\x1a1github.com/TheThingsNetwork/api/trace/\
    trace.proto\"\xbd\x02\n\x0eDownlinkOption\x12\x1e\n\nidentifier\x18\x01\
    \x20\x01(\tR\nidentifier\x12,\n\ngateway_id\x18\x02\x20\x01(\tR\tgateway\
    IdB\r\xe2\xde\x1f\tGatewayID\x12\x14\n\x05score\x18\x03\x20\x01(\rR\x05s\
    core\x12\x1a\n\x08deadline\x18\x04\x20\x01(\x03R\x08deadline\x12V\n\x16p\
    rotocol_configuration\x18\x05\x20\x01(\x0b2\x19.protocol.TxConfiguration\
    R\x15protocolConfigurationB\x04\xc8\xde\x1f\0\x12S\n\x15gateway_configur\
    ation\x18\x06\x20\x01(\x0b2\x18.gateway.TxConfigurationR\x14gatewayConfi\
    gurationB\x04\xc8\xde\x1f\0\"\xc4\x04\n\rUplinkMessage\x12\x18\n\x07payl\
    oad\x18\x01\x20\x01(\x0cR\x07payload\x12+\n\x07message\x18\x02\x20\x01(\
    \x0b2\x11.protocol.MessageR\x07message\x12X\n\x07dev_eui\x18\x0b\x20\x01\
    (\x0cR\x06devEuiB?\xe2\xde\x1f\x06DevEUI\xda\xde\x1f1github.com/TheThing\
    sNetwork/ttn/core/types.DevEUI\x12X\n\x07app_eui\x18\x0c\x20\x01(\x0cR\
    \x06appEuiB?\xe2\xde\x1f\x06AppEUI\xda\xde\x1f1github.com/TheThingsNetwo\
    rk/ttn/core/types.AppEUI\x12\x20\n\x06app_id\x18\r\x20\x01(\tR\x05appIdB\
    \t\xe2\xde\x1f\x05AppID\x12\x20\n\x06dev_id\x18\x0e\x20\x01(\tR\x05devId\
    B\t\xe2\xde\x1f\x05DevID\x12G\n\x11protocol_metadata\x18\x15\x20\x01(\
    \x0b2\x14.protocol.RxMetadataR\x10protocolMetadataB\x04\xc8\xde\x1f\0\
    \x12D\n\x10gateway_metadata\x18\x16\x20\x01(\x0b2\x13.gateway.RxMetadata\
    R\x0fgatewayMetadataB\x04\xc8\xde\x1f\0\x12A\n\x10downlink_options\x18\
    \x1f\x20\x03(\x0b2\x16.broker.DownlinkOptionR\x0fdownlinkOptions\x12\"\n\
    \x05trace\x18)\x20\x01(\x0b2\x0c.trace.TraceR\x05trace\"\xbd\x03\n\x0fDo\
    wnlinkMessage\x12\x18\n\x07payload\x18\x01\x20\x01(\x0cR\x07payload\x12+\
    \n\x07message\x18\x02\x20\x01(\x0b2\x11.protocol.MessageR\x07message\x12\
    \\\n\x07dev_eui\x18\x0b\x20\x01(\x0cR\x06devEuiBC\xe2\xde\x1f\x06DevEUI\
    \xda\xde\x1f1github.com/TheThingsNetwork/ttn/core/types.DevEUI\xc8\xde\
    \x1f\0\x12\\\n\x07app_eui\x18\x0c\x20\x01(\x0cR\x06appEuiBC\xc8\xde\x1f\
    \0\xe2\xde\x1f\x06AppEUI\xda\xde\x1f1github.com/TheThingsNetwork/ttn/cor\
    e/types.AppEUI\x12\x20\n\x06app_id\x18\r\x20\x01(\tR\x05appIdB\t\xe2\xde\
    \x1f\x05AppID\x12\x20\n\x06dev_id\x18\x0e\x20\x01(\tR\x05devIdB\t\xe2\
    \xde\x1f\x05DevID\x12?\n\x0fdownlink_option\x18\x15\x20\x01(\x0b2\x16.br\
    oker.DownlinkOptionR\x0edownlinkOption\x12\"\n\x05trace\x18\x1f\x20\x01(\
    \x0b2\x0c.trace.TraceR\x05trace\"\xc6\x01\n\x18DeviceActivationResponse\
    \x12\x18\n\x07payload\x18\x01\x20\x01(\x0cR\x07payload\x12+\n\x07message\
    \x18\x02\x20\x01(\x0b2\x11.protocol.MessageR\x07message\x12?\n\x0fdownli\
    nk_option\x18\x0b\x20\x01(\x0b2\x16.broker.DownlinkOptionR\x0edownlinkOp\
    tion\x12\"\n\x05trace\x18\x15\x20\x01(\x0b2\x0c.trace.TraceR\x05trace\"\
    \xee\x04\n\x19DeduplicatedUplinkMessage\x12\x18\n\x07payload\x18\x01\x20\
    \x01(\x0cR\x07payload\x12+\n\x07message\x18\x02\x20\x01(\x0b2\x11.protoc\
    ol.MessageR\x07message\x12X\n\x07dev_eui\x18\x0b\x20\x01(\x0cR\x06devEui\
    B?\xda\xde\x1f1github.com/TheThingsNetwork/ttn/core/types.DevEUI\xe2\xde\
    \x1f\x06DevEUI\x12X\n\x07app_eui\x18\x0c\x20\x01(\x0cR\x06appEuiB?\xda\
    \xde\x1f1github.com/TheThingsNetwork/ttn/core/types.AppEUI\xe2\xde\x1f\
    \x06AppEUI\x12\x20\n\x06app_id\x18\r\x20\x01(\tR\x05appIdB\t\xe2\xde\x1f\
    \x05AppID\x12\x20\n\x06dev_id\x18\x0e\x20\x01(\tR\x05devIdB\t\xe2\xde\
    \x1f\x05DevID\x12G\n\x11protocol_metadata\x18\x15\x20\x01(\x0b2\x14.prot\
    ocol.RxMetadataR\x10protocolMetadataB\x04\xc8\xde\x1f\0\x12>\n\x10gatewa\
    y_metadata\x18\x16\x20\x03(\x0b2\x13.gateway.RxMetadataR\x0fgatewayMetad\
    ata\x12\x1f\n\x0bserver_time\x18\x17\x20\x01(\x03R\nserverTime\x12D\n\
    \x11response_template\x18\x1f\x20\x01(\x0b2\x17.broker.DownlinkMessageR\
    \x10responseTemplate\x12\"\n\x05trace\x18)\x20\x01(\x0b2\x0c.trace.Trace\
    R\x05trace\"\xe1\x04\n\x17DeviceActivationRequest\x12\x18\n\x07payload\
    \x18\x01\x20\x01(\x0cR\x07payload\x12+\n\x07message\x18\x02\x20\x01(\x0b\
    2\x11.protocol.MessageR\x07message\x12\\\n\x07dev_eui\x18\x0b\x20\x01(\
    \x0cR\x06devEuiBC\xe2\xde\x1f\x06DevEUI\xc8\xde\x1f\0\xda\xde\x1f1github\
    .com/TheThingsNetwork/ttn/core/types.DevEUI\x12\\\n\x07app_eui\x18\x0c\
    \x20\x01(\x0cR\x06appEuiBC\xe2\xde\x1f\x06AppEUI\xc8\xde\x1f\0\xda\xde\
    \x1f1github.com/TheThingsNetwork/ttn/core/types.AppEUI\x12G\n\x11protoco\
    l_metadata\x18\x15\x20\x01(\x0b2\x14.protocol.RxMetadataR\x10protocolMet\
    adataB\x04\xc8\xde\x1f\0\x12D\n\x10gateway_metadata\x18\x16\x20\x01(\x0b\
    2\x13.gateway.RxMetadataR\x0fgatewayMetadataB\x04\xc8\xde\x1f\0\x12M\n\
    \x13activation_metadata\x18\x17\x20\x01(\x0b2\x1c.protocol.ActivationMet\
    adataR\x12activationMetadata\x12A\n\x10downlink_options\x18\x1f\x20\x03(\
    \x0b2\x16.broker.DownlinkOptionR\x0fdownlinkOptions\x12\"\n\x05trace\x18\
    )\x20\x01(\x0b2\x0c.trace.TraceR\x05trace\"\xd8\x05\n#DeduplicatedDevice\
    ActivationRequest\x12\x18\n\x07payload\x18\x01\x20\x01(\x0cR\x07payload\
    \x12+\n\x07message\x18\x02\x20\x01(\x0b2\x11.protocol.MessageR\x07messag\
    e\x12\\\n\x07dev_eui\x18\x0b\x20\x01(\x0cR\x06devEuiBC\xda\xde\x1f1githu\
    b.com/TheThingsNetwork/ttn/core/types.DevEUI\xc8\xde\x1f\0\xe2\xde\x1f\
    \x06DevEUI\x12\\\n\x07app_eui\x18\x0c\x20\x01(\x0cR\x06appEuiBC\xe2\xde\
    \x1f\x06AppEUI\xc8\xde\x1f\0\xda\xde\x1f1github.com/TheThingsNetwork/ttn\
    /core/types.AppEUI\x12\x20\n\x06app_id\x18\r\x20\x01(\tR\x05appIdB\t\xe2\
    \xde\x1f\x05AppID\x12\x20\n\x06dev_id\x18\x0e\x20\x01(\tR\x05devIdB\t\
    \xe2\xde\x1f\x05DevID\x12G\n\x11protocol_metadata\x18\x15\x20\x01(\x0b2\
    \x14.protocol.RxMetadataR\x10protocolMetadataB\x04\xc8\xde\x1f\0\x12>\n\
    \x10gateway_metadata\x18\x16\x20\x03(\x0b2\x13.gateway.RxMetadataR\x0fga\
    tewayMetadata\x12M\n\x13activation_metadata\x18\x17\x20\x01(\x0b2\x1c.pr\
    otocol.ActivationMetadataR\x12activationMetadata\x12\x1f\n\x0bserver_tim\
    e\x18\x18\x20\x01(\x03R\nserverTime\x12M\n\x11response_template\x18\x1f\
    \x20\x01(\x0b2\x20.broker.DeviceActivationResponseR\x10responseTemplate\
    \x12\"\n\x05trace\x18)\x20\x01(\x0b2\x0c.trace.TraceR\x05trace\"\xe3\x02\
    \n\x1aActivationChallengeRequest\x12\x18\n\x07payload\x18\x01\x20\x01(\
    \x0cR\x07payload\x12+\n\x07message\x18\x02\x20\x01(\x0b2\x11.protocol.Me\
    ssageR\x07message\x12\\\n\x07dev_eui\x18\x0b\x20\x01(\x0cR\x06devEuiBC\
    \xc8\xde\x1f\0\xda\xde\x1f1github.com/TheThingsNetwork/ttn/core/types.De\
    vEUI\xe2\xde\x1f\x06DevEUI\x12\\\n\x07app_eui\x18\x0c\x20\x01(\x0cR\x06a\
    ppEuiBC\xe2\xde\x1f\x06AppEUI\xc8\xde\x1f\0\xda\xde\x1f1github.com/TheTh\
    ingsNetwork/ttn/core/types.AppEUI\x12\x20\n\x06app_id\x18\r\x20\x01(\tR\
    \x05appIdB\t\xe2\xde\x1f\x05AppID\x12\x20\n\x06dev_id\x18\x0e\x20\x01(\t\
    R\x05devIdB\t\xe2\xde\x1f\x05DevID\"d\n\x1bActivationChallengeResponse\
    \x12\x18\n\x07payload\x18\x01\x20\x01(\x0cR\x07payload\x12+\n\x07message\
    \x18\x02\x20\x01(\x0b2\x11.protocol.MessageR\x07message\"\x12\n\x10Subsc\
    ribeRequest\"\x0f\n\rStatusRequest\"\xeb\x03\n\x06Status\x12.\n\x06syste\
    m\x18\x01\x20\x01(\x0b2\x10.api.SystemStatsR\x06systemB\x04\xc8\xde\x1f\
    \0\x127\n\tcomponent\x18\x02\x20\x01(\x0b2\x13.api.ComponentStatsR\tcomp\
    onentB\x04\xc8\xde\x1f\0\x12\"\n\x06uplink\x18\x0b\x20\x01(\x0b2\n.api.R\
    atesR\x06uplink\x12/\n\ruplink_unique\x18\x0c\x20\x01(\x0b2\n.api.RatesR\
    \x0cuplinkUnique\x12&\n\x08downlink\x18\r\x20\x01(\x0b2\n.api.RatesR\x08\
    downlink\x12,\n\x0bactivations\x18\x0e\x20\x01(\x0b2\n.api.RatesR\x0bact\
    ivations\x129\n\x12activations_unique\x18\x0f\x20\x01(\x0b2\n.api.RatesR\
    \x11activationsUnique\x126\n\rdeduplication\x18\x10\x20\x01(\x0b2\x10.ap\
    i.PercentilesR\rdeduplication\x12+\n\x11connected_routers\x18\x15\x20\
    \x01(\rR\x10connectedRouters\x12-\n\x12connected_handlers\x18\x16\x20\
    \x01(\rR\x11connectedHandlers\"p\n\x1eApplicationHandlerRegistration\x12\
    \x20\n\x06app_id\x18\x01\x20\x01(\tR\x05appIdB\t\xe2\xde\x1f\x05AppID\
    \x12,\n\nhandler_id\x18\x02\x20\x01(\tR\thandlerIdB\r\xe2\xde\x1f\tHandl\
    erID2\xa2\x02\n\x06Broker\x12?\n\tAssociate\x12\x15.broker.UplinkMessage\
    \x1a\x17.broker.DownlinkMessage(\x010\x01\x12J\n\tSubscribe\x12\x18.brok\
    er.SubscribeRequest\x1a!.broker.DeduplicatedUplinkMessage0\x01\x12<\n\
    \x07Publish\x12\x17.broker.DownlinkMessage\x1a\x16.google.protobuf.Empty\
    (\x01\x12M\n\x08Activate\x12\x1f.broker.DeviceActivationRequest\x1a\x20.\
    broker.DeviceActivationResponse2\xa1\x01\n\rBrokerManager\x12\\\n\x1aReg\
    isterApplicationHandler\x12&.broker.ApplicationHandlerRegistration\x1a\
    \x16.google.protobuf.Empty\x122\n\tGetStatus\x12\x15.broker.StatusReques\
    t\x1a\x0e.broker.StatusBv\n\x1forg.thethingsnetwork.api.brokerB\x0bBroke\
    rProtoP\x01Z&github.com/TheThingsNetwork/api/broker\xaa\x02\x1bTheThings\
    Network.API.Brokerb\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
