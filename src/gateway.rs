// This file is generated by rust-protobuf 2.6.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct LocationMetadata {
    // message fields
    pub time: i64,
    pub latitude: f32,
    pub longitude: f32,
    pub altitude: i32,
    pub accuracy: i32,
    pub source: LocationMetadata_LocationSource,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LocationMetadata {
    fn default() -> &'a LocationMetadata {
        <LocationMetadata as ::protobuf::Message>::default_instance()
    }
}

impl LocationMetadata {
    pub fn new() -> LocationMetadata {
        ::std::default::Default::default()
    }

    // int64 time = 1;


    pub fn get_time(&self) -> i64 {
        self.time
    }
    pub fn clear_time(&mut self) {
        self.time = 0;
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: i64) {
        self.time = v;
    }

    // float latitude = 2;


    pub fn get_latitude(&self) -> f32 {
        self.latitude
    }
    pub fn clear_latitude(&mut self) {
        self.latitude = 0.;
    }

    // Param is passed by value, moved
    pub fn set_latitude(&mut self, v: f32) {
        self.latitude = v;
    }

    // float longitude = 3;


    pub fn get_longitude(&self) -> f32 {
        self.longitude
    }
    pub fn clear_longitude(&mut self) {
        self.longitude = 0.;
    }

    // Param is passed by value, moved
    pub fn set_longitude(&mut self, v: f32) {
        self.longitude = v;
    }

    // int32 altitude = 4;


    pub fn get_altitude(&self) -> i32 {
        self.altitude
    }
    pub fn clear_altitude(&mut self) {
        self.altitude = 0;
    }

    // Param is passed by value, moved
    pub fn set_altitude(&mut self, v: i32) {
        self.altitude = v;
    }

    // int32 accuracy = 5;


    pub fn get_accuracy(&self) -> i32 {
        self.accuracy
    }
    pub fn clear_accuracy(&mut self) {
        self.accuracy = 0;
    }

    // Param is passed by value, moved
    pub fn set_accuracy(&mut self, v: i32) {
        self.accuracy = v;
    }

    // .gateway.LocationMetadata.LocationSource source = 6;


    pub fn get_source(&self) -> LocationMetadata_LocationSource {
        self.source
    }
    pub fn clear_source(&mut self) {
        self.source = LocationMetadata_LocationSource::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: LocationMetadata_LocationSource) {
        self.source = v;
    }
}

impl ::protobuf::Message for LocationMetadata {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.time = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.latitude = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.longitude = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.altitude = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.accuracy = tmp;
                },
                6 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.source, 6, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.time != 0 {
            my_size += ::protobuf::rt::value_size(1, self.time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.latitude != 0. {
            my_size += 5;
        }
        if self.longitude != 0. {
            my_size += 5;
        }
        if self.altitude != 0 {
            my_size += ::protobuf::rt::value_size(4, self.altitude, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.accuracy != 0 {
            my_size += ::protobuf::rt::value_size(5, self.accuracy, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.source != LocationMetadata_LocationSource::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(6, self.source);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.time != 0 {
            os.write_int64(1, self.time)?;
        }
        if self.latitude != 0. {
            os.write_float(2, self.latitude)?;
        }
        if self.longitude != 0. {
            os.write_float(3, self.longitude)?;
        }
        if self.altitude != 0 {
            os.write_int32(4, self.altitude)?;
        }
        if self.accuracy != 0 {
            os.write_int32(5, self.accuracy)?;
        }
        if self.source != LocationMetadata_LocationSource::UNKNOWN {
            os.write_enum(6, self.source.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LocationMetadata {
        LocationMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "time",
                    |m: &LocationMetadata| { &m.time },
                    |m: &mut LocationMetadata| { &mut m.time },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "latitude",
                    |m: &LocationMetadata| { &m.latitude },
                    |m: &mut LocationMetadata| { &mut m.latitude },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "longitude",
                    |m: &LocationMetadata| { &m.longitude },
                    |m: &mut LocationMetadata| { &mut m.longitude },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "altitude",
                    |m: &LocationMetadata| { &m.altitude },
                    |m: &mut LocationMetadata| { &mut m.altitude },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "accuracy",
                    |m: &LocationMetadata| { &m.accuracy },
                    |m: &mut LocationMetadata| { &mut m.accuracy },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<LocationMetadata_LocationSource>>(
                    "source",
                    |m: &LocationMetadata| { &m.source },
                    |m: &mut LocationMetadata| { &mut m.source },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LocationMetadata>(
                    "LocationMetadata",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LocationMetadata {
        static mut instance: ::protobuf::lazy::Lazy<LocationMetadata> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LocationMetadata,
        };
        unsafe {
            instance.get(LocationMetadata::new)
        }
    }
}

impl ::protobuf::Clear for LocationMetadata {
    fn clear(&mut self) {
        self.time = 0;
        self.latitude = 0.;
        self.longitude = 0.;
        self.altitude = 0;
        self.accuracy = 0;
        self.source = LocationMetadata_LocationSource::UNKNOWN;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LocationMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LocationMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum LocationMetadata_LocationSource {
    UNKNOWN = 0,
    GPS = 1,
    CONFIG = 2,
    REGISTRY = 3,
    IP_GEOLOCATION = 4,
}

impl ::protobuf::ProtobufEnum for LocationMetadata_LocationSource {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LocationMetadata_LocationSource> {
        match value {
            0 => ::std::option::Option::Some(LocationMetadata_LocationSource::UNKNOWN),
            1 => ::std::option::Option::Some(LocationMetadata_LocationSource::GPS),
            2 => ::std::option::Option::Some(LocationMetadata_LocationSource::CONFIG),
            3 => ::std::option::Option::Some(LocationMetadata_LocationSource::REGISTRY),
            4 => ::std::option::Option::Some(LocationMetadata_LocationSource::IP_GEOLOCATION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [LocationMetadata_LocationSource] = &[
            LocationMetadata_LocationSource::UNKNOWN,
            LocationMetadata_LocationSource::GPS,
            LocationMetadata_LocationSource::CONFIG,
            LocationMetadata_LocationSource::REGISTRY,
            LocationMetadata_LocationSource::IP_GEOLOCATION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("LocationMetadata_LocationSource", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for LocationMetadata_LocationSource {
}

impl ::std::default::Default for LocationMetadata_LocationSource {
    fn default() -> Self {
        LocationMetadata_LocationSource::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for LocationMetadata_LocationSource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RxMetadata {
    // message fields
    pub gateway_id: ::std::string::String,
    pub gateway_trusted: bool,
    pub timestamp: u32,
    pub time: i64,
    pub encrypted_time: ::std::vec::Vec<u8>,
    pub rf_chain: u32,
    pub channel: u32,
    pub antennas: ::protobuf::RepeatedField<RxMetadata_Antenna>,
    pub frequency: u64,
    pub rssi: f32,
    pub snr: f32,
    pub location: ::protobuf::SingularPtrField<LocationMetadata>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RxMetadata {
    fn default() -> &'a RxMetadata {
        <RxMetadata as ::protobuf::Message>::default_instance()
    }
}

impl RxMetadata {
    pub fn new() -> RxMetadata {
        ::std::default::Default::default()
    }

    // string gateway_id = 1;


    pub fn get_gateway_id(&self) -> &str {
        &self.gateway_id
    }
    pub fn clear_gateway_id(&mut self) {
        self.gateway_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_gateway_id(&mut self, v: ::std::string::String) {
        self.gateway_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gateway_id(&mut self) -> &mut ::std::string::String {
        &mut self.gateway_id
    }

    // Take field
    pub fn take_gateway_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.gateway_id, ::std::string::String::new())
    }

    // bool gateway_trusted = 2;


    pub fn get_gateway_trusted(&self) -> bool {
        self.gateway_trusted
    }
    pub fn clear_gateway_trusted(&mut self) {
        self.gateway_trusted = false;
    }

    // Param is passed by value, moved
    pub fn set_gateway_trusted(&mut self, v: bool) {
        self.gateway_trusted = v;
    }

    // uint32 timestamp = 11;


    pub fn get_timestamp(&self) -> u32 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = v;
    }

    // int64 time = 12;


    pub fn get_time(&self) -> i64 {
        self.time
    }
    pub fn clear_time(&mut self) {
        self.time = 0;
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: i64) {
        self.time = v;
    }

    // bytes encrypted_time = 13;


    pub fn get_encrypted_time(&self) -> &[u8] {
        &self.encrypted_time
    }
    pub fn clear_encrypted_time(&mut self) {
        self.encrypted_time.clear();
    }

    // Param is passed by value, moved
    pub fn set_encrypted_time(&mut self, v: ::std::vec::Vec<u8>) {
        self.encrypted_time = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encrypted_time(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.encrypted_time
    }

    // Take field
    pub fn take_encrypted_time(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.encrypted_time, ::std::vec::Vec::new())
    }

    // uint32 rf_chain = 21;


    pub fn get_rf_chain(&self) -> u32 {
        self.rf_chain
    }
    pub fn clear_rf_chain(&mut self) {
        self.rf_chain = 0;
    }

    // Param is passed by value, moved
    pub fn set_rf_chain(&mut self, v: u32) {
        self.rf_chain = v;
    }

    // uint32 channel = 22;


    pub fn get_channel(&self) -> u32 {
        self.channel
    }
    pub fn clear_channel(&mut self) {
        self.channel = 0;
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: u32) {
        self.channel = v;
    }

    // repeated .gateway.RxMetadata.Antenna antennas = 30;


    pub fn get_antennas(&self) -> &[RxMetadata_Antenna] {
        &self.antennas
    }
    pub fn clear_antennas(&mut self) {
        self.antennas.clear();
    }

    // Param is passed by value, moved
    pub fn set_antennas(&mut self, v: ::protobuf::RepeatedField<RxMetadata_Antenna>) {
        self.antennas = v;
    }

    // Mutable pointer to the field.
    pub fn mut_antennas(&mut self) -> &mut ::protobuf::RepeatedField<RxMetadata_Antenna> {
        &mut self.antennas
    }

    // Take field
    pub fn take_antennas(&mut self) -> ::protobuf::RepeatedField<RxMetadata_Antenna> {
        ::std::mem::replace(&mut self.antennas, ::protobuf::RepeatedField::new())
    }

    // uint64 frequency = 31;


    pub fn get_frequency(&self) -> u64 {
        self.frequency
    }
    pub fn clear_frequency(&mut self) {
        self.frequency = 0;
    }

    // Param is passed by value, moved
    pub fn set_frequency(&mut self, v: u64) {
        self.frequency = v;
    }

    // float rssi = 32;


    pub fn get_rssi(&self) -> f32 {
        self.rssi
    }
    pub fn clear_rssi(&mut self) {
        self.rssi = 0.;
    }

    // Param is passed by value, moved
    pub fn set_rssi(&mut self, v: f32) {
        self.rssi = v;
    }

    // float snr = 33;


    pub fn get_snr(&self) -> f32 {
        self.snr
    }
    pub fn clear_snr(&mut self) {
        self.snr = 0.;
    }

    // Param is passed by value, moved
    pub fn set_snr(&mut self, v: f32) {
        self.snr = v;
    }

    // .gateway.LocationMetadata location = 41;


    pub fn get_location(&self) -> &LocationMetadata {
        self.location.as_ref().unwrap_or_else(|| LocationMetadata::default_instance())
    }
    pub fn clear_location(&mut self) {
        self.location.clear();
    }

    pub fn has_location(&self) -> bool {
        self.location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: LocationMetadata) {
        self.location = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location(&mut self) -> &mut LocationMetadata {
        if self.location.is_none() {
            self.location.set_default();
        }
        self.location.as_mut().unwrap()
    }

    // Take field
    pub fn take_location(&mut self) -> LocationMetadata {
        self.location.take().unwrap_or_else(|| LocationMetadata::new())
    }
}

impl ::protobuf::Message for RxMetadata {
    fn is_initialized(&self) -> bool {
        for v in &self.antennas {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.location {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.gateway_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.gateway_trusted = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.time = tmp;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.encrypted_time)?;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rf_chain = tmp;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.channel = tmp;
                },
                30 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.antennas)?;
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.frequency = tmp;
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.rssi = tmp;
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.snr = tmp;
                },
                41 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.location)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.gateway_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.gateway_id);
        }
        if self.gateway_trusted != false {
            my_size += 2;
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(11, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.time != 0 {
            my_size += ::protobuf::rt::value_size(12, self.time, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.encrypted_time.is_empty() {
            my_size += ::protobuf::rt::bytes_size(13, &self.encrypted_time);
        }
        if self.rf_chain != 0 {
            my_size += ::protobuf::rt::value_size(21, self.rf_chain, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.channel != 0 {
            my_size += ::protobuf::rt::value_size(22, self.channel, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.antennas {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.frequency != 0 {
            my_size += ::protobuf::rt::value_size(31, self.frequency, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rssi != 0. {
            my_size += 6;
        }
        if self.snr != 0. {
            my_size += 6;
        }
        if let Some(ref v) = self.location.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.gateway_id.is_empty() {
            os.write_string(1, &self.gateway_id)?;
        }
        if self.gateway_trusted != false {
            os.write_bool(2, self.gateway_trusted)?;
        }
        if self.timestamp != 0 {
            os.write_uint32(11, self.timestamp)?;
        }
        if self.time != 0 {
            os.write_int64(12, self.time)?;
        }
        if !self.encrypted_time.is_empty() {
            os.write_bytes(13, &self.encrypted_time)?;
        }
        if self.rf_chain != 0 {
            os.write_uint32(21, self.rf_chain)?;
        }
        if self.channel != 0 {
            os.write_uint32(22, self.channel)?;
        }
        for v in &self.antennas {
            os.write_tag(30, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.frequency != 0 {
            os.write_uint64(31, self.frequency)?;
        }
        if self.rssi != 0. {
            os.write_float(32, self.rssi)?;
        }
        if self.snr != 0. {
            os.write_float(33, self.snr)?;
        }
        if let Some(ref v) = self.location.as_ref() {
            os.write_tag(41, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RxMetadata {
        RxMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gateway_id",
                    |m: &RxMetadata| { &m.gateway_id },
                    |m: &mut RxMetadata| { &mut m.gateway_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "gateway_trusted",
                    |m: &RxMetadata| { &m.gateway_trusted },
                    |m: &mut RxMetadata| { &mut m.gateway_trusted },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timestamp",
                    |m: &RxMetadata| { &m.timestamp },
                    |m: &mut RxMetadata| { &mut m.timestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "time",
                    |m: &RxMetadata| { &m.time },
                    |m: &mut RxMetadata| { &mut m.time },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "encrypted_time",
                    |m: &RxMetadata| { &m.encrypted_time },
                    |m: &mut RxMetadata| { &mut m.encrypted_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rf_chain",
                    |m: &RxMetadata| { &m.rf_chain },
                    |m: &mut RxMetadata| { &mut m.rf_chain },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "channel",
                    |m: &RxMetadata| { &m.channel },
                    |m: &mut RxMetadata| { &mut m.channel },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RxMetadata_Antenna>>(
                    "antennas",
                    |m: &RxMetadata| { &m.antennas },
                    |m: &mut RxMetadata| { &mut m.antennas },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "frequency",
                    |m: &RxMetadata| { &m.frequency },
                    |m: &mut RxMetadata| { &mut m.frequency },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "rssi",
                    |m: &RxMetadata| { &m.rssi },
                    |m: &mut RxMetadata| { &mut m.rssi },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "snr",
                    |m: &RxMetadata| { &m.snr },
                    |m: &mut RxMetadata| { &mut m.snr },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocationMetadata>>(
                    "location",
                    |m: &RxMetadata| { &m.location },
                    |m: &mut RxMetadata| { &mut m.location },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RxMetadata>(
                    "RxMetadata",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RxMetadata {
        static mut instance: ::protobuf::lazy::Lazy<RxMetadata> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RxMetadata,
        };
        unsafe {
            instance.get(RxMetadata::new)
        }
    }
}

impl ::protobuf::Clear for RxMetadata {
    fn clear(&mut self) {
        self.gateway_id.clear();
        self.gateway_trusted = false;
        self.timestamp = 0;
        self.time = 0;
        self.encrypted_time.clear();
        self.rf_chain = 0;
        self.channel = 0;
        self.antennas.clear();
        self.frequency = 0;
        self.rssi = 0.;
        self.snr = 0.;
        self.location.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RxMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RxMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RxMetadata_Antenna {
    // message fields
    pub antenna: u32,
    pub channel: u32,
    pub rssi: f32,
    pub channel_rssi: f32,
    pub rssi_standard_deviation: f32,
    pub frequency_offset: i64,
    pub snr: f32,
    pub encrypted_time: ::std::vec::Vec<u8>,
    pub fine_time: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RxMetadata_Antenna {
    fn default() -> &'a RxMetadata_Antenna {
        <RxMetadata_Antenna as ::protobuf::Message>::default_instance()
    }
}

impl RxMetadata_Antenna {
    pub fn new() -> RxMetadata_Antenna {
        ::std::default::Default::default()
    }

    // uint32 antenna = 1;


    pub fn get_antenna(&self) -> u32 {
        self.antenna
    }
    pub fn clear_antenna(&mut self) {
        self.antenna = 0;
    }

    // Param is passed by value, moved
    pub fn set_antenna(&mut self, v: u32) {
        self.antenna = v;
    }

    // uint32 channel = 2;


    pub fn get_channel(&self) -> u32 {
        self.channel
    }
    pub fn clear_channel(&mut self) {
        self.channel = 0;
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: u32) {
        self.channel = v;
    }

    // float rssi = 3;


    pub fn get_rssi(&self) -> f32 {
        self.rssi
    }
    pub fn clear_rssi(&mut self) {
        self.rssi = 0.;
    }

    // Param is passed by value, moved
    pub fn set_rssi(&mut self, v: f32) {
        self.rssi = v;
    }

    // float channel_rssi = 5;


    pub fn get_channel_rssi(&self) -> f32 {
        self.channel_rssi
    }
    pub fn clear_channel_rssi(&mut self) {
        self.channel_rssi = 0.;
    }

    // Param is passed by value, moved
    pub fn set_channel_rssi(&mut self, v: f32) {
        self.channel_rssi = v;
    }

    // float rssi_standard_deviation = 6;


    pub fn get_rssi_standard_deviation(&self) -> f32 {
        self.rssi_standard_deviation
    }
    pub fn clear_rssi_standard_deviation(&mut self) {
        self.rssi_standard_deviation = 0.;
    }

    // Param is passed by value, moved
    pub fn set_rssi_standard_deviation(&mut self, v: f32) {
        self.rssi_standard_deviation = v;
    }

    // int64 frequency_offset = 7;


    pub fn get_frequency_offset(&self) -> i64 {
        self.frequency_offset
    }
    pub fn clear_frequency_offset(&mut self) {
        self.frequency_offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_frequency_offset(&mut self, v: i64) {
        self.frequency_offset = v;
    }

    // float snr = 4;


    pub fn get_snr(&self) -> f32 {
        self.snr
    }
    pub fn clear_snr(&mut self) {
        self.snr = 0.;
    }

    // Param is passed by value, moved
    pub fn set_snr(&mut self, v: f32) {
        self.snr = v;
    }

    // bytes encrypted_time = 10;


    pub fn get_encrypted_time(&self) -> &[u8] {
        &self.encrypted_time
    }
    pub fn clear_encrypted_time(&mut self) {
        self.encrypted_time.clear();
    }

    // Param is passed by value, moved
    pub fn set_encrypted_time(&mut self, v: ::std::vec::Vec<u8>) {
        self.encrypted_time = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encrypted_time(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.encrypted_time
    }

    // Take field
    pub fn take_encrypted_time(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.encrypted_time, ::std::vec::Vec::new())
    }

    // int64 fine_time = 11;


    pub fn get_fine_time(&self) -> i64 {
        self.fine_time
    }
    pub fn clear_fine_time(&mut self) {
        self.fine_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_fine_time(&mut self, v: i64) {
        self.fine_time = v;
    }
}

impl ::protobuf::Message for RxMetadata_Antenna {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.antenna = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.channel = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.rssi = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.channel_rssi = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.rssi_standard_deviation = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.frequency_offset = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.snr = tmp;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.encrypted_time)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fine_time = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.antenna != 0 {
            my_size += ::protobuf::rt::value_size(1, self.antenna, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.channel != 0 {
            my_size += ::protobuf::rt::value_size(2, self.channel, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rssi != 0. {
            my_size += 5;
        }
        if self.channel_rssi != 0. {
            my_size += 5;
        }
        if self.rssi_standard_deviation != 0. {
            my_size += 5;
        }
        if self.frequency_offset != 0 {
            my_size += ::protobuf::rt::value_size(7, self.frequency_offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.snr != 0. {
            my_size += 5;
        }
        if !self.encrypted_time.is_empty() {
            my_size += ::protobuf::rt::bytes_size(10, &self.encrypted_time);
        }
        if self.fine_time != 0 {
            my_size += ::protobuf::rt::value_size(11, self.fine_time, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.antenna != 0 {
            os.write_uint32(1, self.antenna)?;
        }
        if self.channel != 0 {
            os.write_uint32(2, self.channel)?;
        }
        if self.rssi != 0. {
            os.write_float(3, self.rssi)?;
        }
        if self.channel_rssi != 0. {
            os.write_float(5, self.channel_rssi)?;
        }
        if self.rssi_standard_deviation != 0. {
            os.write_float(6, self.rssi_standard_deviation)?;
        }
        if self.frequency_offset != 0 {
            os.write_int64(7, self.frequency_offset)?;
        }
        if self.snr != 0. {
            os.write_float(4, self.snr)?;
        }
        if !self.encrypted_time.is_empty() {
            os.write_bytes(10, &self.encrypted_time)?;
        }
        if self.fine_time != 0 {
            os.write_int64(11, self.fine_time)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RxMetadata_Antenna {
        RxMetadata_Antenna::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "antenna",
                    |m: &RxMetadata_Antenna| { &m.antenna },
                    |m: &mut RxMetadata_Antenna| { &mut m.antenna },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "channel",
                    |m: &RxMetadata_Antenna| { &m.channel },
                    |m: &mut RxMetadata_Antenna| { &mut m.channel },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "rssi",
                    |m: &RxMetadata_Antenna| { &m.rssi },
                    |m: &mut RxMetadata_Antenna| { &mut m.rssi },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "channel_rssi",
                    |m: &RxMetadata_Antenna| { &m.channel_rssi },
                    |m: &mut RxMetadata_Antenna| { &mut m.channel_rssi },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "rssi_standard_deviation",
                    |m: &RxMetadata_Antenna| { &m.rssi_standard_deviation },
                    |m: &mut RxMetadata_Antenna| { &mut m.rssi_standard_deviation },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "frequency_offset",
                    |m: &RxMetadata_Antenna| { &m.frequency_offset },
                    |m: &mut RxMetadata_Antenna| { &mut m.frequency_offset },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "snr",
                    |m: &RxMetadata_Antenna| { &m.snr },
                    |m: &mut RxMetadata_Antenna| { &mut m.snr },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "encrypted_time",
                    |m: &RxMetadata_Antenna| { &m.encrypted_time },
                    |m: &mut RxMetadata_Antenna| { &mut m.encrypted_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "fine_time",
                    |m: &RxMetadata_Antenna| { &m.fine_time },
                    |m: &mut RxMetadata_Antenna| { &mut m.fine_time },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RxMetadata_Antenna>(
                    "RxMetadata_Antenna",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RxMetadata_Antenna {
        static mut instance: ::protobuf::lazy::Lazy<RxMetadata_Antenna> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RxMetadata_Antenna,
        };
        unsafe {
            instance.get(RxMetadata_Antenna::new)
        }
    }
}

impl ::protobuf::Clear for RxMetadata_Antenna {
    fn clear(&mut self) {
        self.antenna = 0;
        self.channel = 0;
        self.rssi = 0.;
        self.channel_rssi = 0.;
        self.rssi_standard_deviation = 0.;
        self.frequency_offset = 0;
        self.snr = 0.;
        self.encrypted_time.clear();
        self.fine_time = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RxMetadata_Antenna {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RxMetadata_Antenna {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TxConfiguration {
    // message fields
    pub timestamp: u32,
    pub rf_chain: u32,
    pub frequency: u64,
    pub power: i32,
    pub polarization_inversion: bool,
    pub frequency_deviation: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TxConfiguration {
    fn default() -> &'a TxConfiguration {
        <TxConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl TxConfiguration {
    pub fn new() -> TxConfiguration {
        ::std::default::Default::default()
    }

    // uint32 timestamp = 11;


    pub fn get_timestamp(&self) -> u32 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = v;
    }

    // uint32 rf_chain = 21;


    pub fn get_rf_chain(&self) -> u32 {
        self.rf_chain
    }
    pub fn clear_rf_chain(&mut self) {
        self.rf_chain = 0;
    }

    // Param is passed by value, moved
    pub fn set_rf_chain(&mut self, v: u32) {
        self.rf_chain = v;
    }

    // uint64 frequency = 22;


    pub fn get_frequency(&self) -> u64 {
        self.frequency
    }
    pub fn clear_frequency(&mut self) {
        self.frequency = 0;
    }

    // Param is passed by value, moved
    pub fn set_frequency(&mut self, v: u64) {
        self.frequency = v;
    }

    // int32 power = 23;


    pub fn get_power(&self) -> i32 {
        self.power
    }
    pub fn clear_power(&mut self) {
        self.power = 0;
    }

    // Param is passed by value, moved
    pub fn set_power(&mut self, v: i32) {
        self.power = v;
    }

    // bool polarization_inversion = 31;


    pub fn get_polarization_inversion(&self) -> bool {
        self.polarization_inversion
    }
    pub fn clear_polarization_inversion(&mut self) {
        self.polarization_inversion = false;
    }

    // Param is passed by value, moved
    pub fn set_polarization_inversion(&mut self, v: bool) {
        self.polarization_inversion = v;
    }

    // uint32 frequency_deviation = 32;


    pub fn get_frequency_deviation(&self) -> u32 {
        self.frequency_deviation
    }
    pub fn clear_frequency_deviation(&mut self) {
        self.frequency_deviation = 0;
    }

    // Param is passed by value, moved
    pub fn set_frequency_deviation(&mut self, v: u32) {
        self.frequency_deviation = v;
    }
}

impl ::protobuf::Message for TxConfiguration {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = tmp;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rf_chain = tmp;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.frequency = tmp;
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.power = tmp;
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.polarization_inversion = tmp;
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.frequency_deviation = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(11, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rf_chain != 0 {
            my_size += ::protobuf::rt::value_size(21, self.rf_chain, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.frequency != 0 {
            my_size += ::protobuf::rt::value_size(22, self.frequency, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.power != 0 {
            my_size += ::protobuf::rt::value_size(23, self.power, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.polarization_inversion != false {
            my_size += 3;
        }
        if self.frequency_deviation != 0 {
            my_size += ::protobuf::rt::value_size(32, self.frequency_deviation, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.timestamp != 0 {
            os.write_uint32(11, self.timestamp)?;
        }
        if self.rf_chain != 0 {
            os.write_uint32(21, self.rf_chain)?;
        }
        if self.frequency != 0 {
            os.write_uint64(22, self.frequency)?;
        }
        if self.power != 0 {
            os.write_int32(23, self.power)?;
        }
        if self.polarization_inversion != false {
            os.write_bool(31, self.polarization_inversion)?;
        }
        if self.frequency_deviation != 0 {
            os.write_uint32(32, self.frequency_deviation)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TxConfiguration {
        TxConfiguration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timestamp",
                    |m: &TxConfiguration| { &m.timestamp },
                    |m: &mut TxConfiguration| { &mut m.timestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rf_chain",
                    |m: &TxConfiguration| { &m.rf_chain },
                    |m: &mut TxConfiguration| { &mut m.rf_chain },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "frequency",
                    |m: &TxConfiguration| { &m.frequency },
                    |m: &mut TxConfiguration| { &mut m.frequency },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "power",
                    |m: &TxConfiguration| { &m.power },
                    |m: &mut TxConfiguration| { &mut m.power },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "polarization_inversion",
                    |m: &TxConfiguration| { &m.polarization_inversion },
                    |m: &mut TxConfiguration| { &mut m.polarization_inversion },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "frequency_deviation",
                    |m: &TxConfiguration| { &m.frequency_deviation },
                    |m: &mut TxConfiguration| { &mut m.frequency_deviation },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TxConfiguration>(
                    "TxConfiguration",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TxConfiguration {
        static mut instance: ::protobuf::lazy::Lazy<TxConfiguration> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TxConfiguration,
        };
        unsafe {
            instance.get(TxConfiguration::new)
        }
    }
}

impl ::protobuf::Clear for TxConfiguration {
    fn clear(&mut self) {
        self.timestamp = 0;
        self.rf_chain = 0;
        self.frequency = 0;
        self.power = 0;
        self.polarization_inversion = false;
        self.frequency_deviation = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TxConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TxConfiguration {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Status {
    // message fields
    pub timestamp: u32,
    pub time: i64,
    pub gateway_trusted: bool,
    pub boot_time: i64,
    pub ip: ::protobuf::RepeatedField<::std::string::String>,
    pub platform: ::std::string::String,
    pub contact_email: ::std::string::String,
    pub description: ::std::string::String,
    pub frequency_plan: ::std::string::String,
    pub bridge: ::std::string::String,
    pub router: ::std::string::String,
    pub fpga: u32,
    pub dsp: u32,
    pub hal: ::std::string::String,
    pub location: ::protobuf::SingularPtrField<LocationMetadata>,
    pub rtt: u32,
    pub rx_in: u32,
    pub rx_ok: u32,
    pub tx_in: u32,
    pub tx_ok: u32,
    pub lm_ok: u32,
    pub lm_st: u32,
    pub lm_nw: u32,
    pub l_pps: u32,
    pub os: ::protobuf::SingularPtrField<Status_OSMetrics>,
    pub messages: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Status {
    fn default() -> &'a Status {
        <Status as ::protobuf::Message>::default_instance()
    }
}

impl Status {
    pub fn new() -> Status {
        ::std::default::Default::default()
    }

    // uint32 timestamp = 1;


    pub fn get_timestamp(&self) -> u32 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = v;
    }

    // int64 time = 2;


    pub fn get_time(&self) -> i64 {
        self.time
    }
    pub fn clear_time(&mut self) {
        self.time = 0;
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: i64) {
        self.time = v;
    }

    // bool gateway_trusted = 3;


    pub fn get_gateway_trusted(&self) -> bool {
        self.gateway_trusted
    }
    pub fn clear_gateway_trusted(&mut self) {
        self.gateway_trusted = false;
    }

    // Param is passed by value, moved
    pub fn set_gateway_trusted(&mut self, v: bool) {
        self.gateway_trusted = v;
    }

    // int64 boot_time = 4;


    pub fn get_boot_time(&self) -> i64 {
        self.boot_time
    }
    pub fn clear_boot_time(&mut self) {
        self.boot_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_boot_time(&mut self, v: i64) {
        self.boot_time = v;
    }

    // repeated string ip = 11;


    pub fn get_ip(&self) -> &[::std::string::String] {
        &self.ip
    }
    pub fn clear_ip(&mut self) {
        self.ip.clear();
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ip = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ip(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ip
    }

    // Take field
    pub fn take_ip(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ip, ::protobuf::RepeatedField::new())
    }

    // string platform = 12;


    pub fn get_platform(&self) -> &str {
        &self.platform
    }
    pub fn clear_platform(&mut self) {
        self.platform.clear();
    }

    // Param is passed by value, moved
    pub fn set_platform(&mut self, v: ::std::string::String) {
        self.platform = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_platform(&mut self) -> &mut ::std::string::String {
        &mut self.platform
    }

    // Take field
    pub fn take_platform(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.platform, ::std::string::String::new())
    }

    // string contact_email = 13;


    pub fn get_contact_email(&self) -> &str {
        &self.contact_email
    }
    pub fn clear_contact_email(&mut self) {
        self.contact_email.clear();
    }

    // Param is passed by value, moved
    pub fn set_contact_email(&mut self, v: ::std::string::String) {
        self.contact_email = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contact_email(&mut self) -> &mut ::std::string::String {
        &mut self.contact_email
    }

    // Take field
    pub fn take_contact_email(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.contact_email, ::std::string::String::new())
    }

    // string description = 14;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // string frequency_plan = 15;


    pub fn get_frequency_plan(&self) -> &str {
        &self.frequency_plan
    }
    pub fn clear_frequency_plan(&mut self) {
        self.frequency_plan.clear();
    }

    // Param is passed by value, moved
    pub fn set_frequency_plan(&mut self, v: ::std::string::String) {
        self.frequency_plan = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_frequency_plan(&mut self) -> &mut ::std::string::String {
        &mut self.frequency_plan
    }

    // Take field
    pub fn take_frequency_plan(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.frequency_plan, ::std::string::String::new())
    }

    // string bridge = 16;


    pub fn get_bridge(&self) -> &str {
        &self.bridge
    }
    pub fn clear_bridge(&mut self) {
        self.bridge.clear();
    }

    // Param is passed by value, moved
    pub fn set_bridge(&mut self, v: ::std::string::String) {
        self.bridge = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bridge(&mut self) -> &mut ::std::string::String {
        &mut self.bridge
    }

    // Take field
    pub fn take_bridge(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bridge, ::std::string::String::new())
    }

    // string router = 17;


    pub fn get_router(&self) -> &str {
        &self.router
    }
    pub fn clear_router(&mut self) {
        self.router.clear();
    }

    // Param is passed by value, moved
    pub fn set_router(&mut self, v: ::std::string::String) {
        self.router = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_router(&mut self) -> &mut ::std::string::String {
        &mut self.router
    }

    // Take field
    pub fn take_router(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.router, ::std::string::String::new())
    }

    // uint32 fpga = 18;


    pub fn get_fpga(&self) -> u32 {
        self.fpga
    }
    pub fn clear_fpga(&mut self) {
        self.fpga = 0;
    }

    // Param is passed by value, moved
    pub fn set_fpga(&mut self, v: u32) {
        self.fpga = v;
    }

    // uint32 dsp = 19;


    pub fn get_dsp(&self) -> u32 {
        self.dsp
    }
    pub fn clear_dsp(&mut self) {
        self.dsp = 0;
    }

    // Param is passed by value, moved
    pub fn set_dsp(&mut self, v: u32) {
        self.dsp = v;
    }

    // string hal = 20;


    pub fn get_hal(&self) -> &str {
        &self.hal
    }
    pub fn clear_hal(&mut self) {
        self.hal.clear();
    }

    // Param is passed by value, moved
    pub fn set_hal(&mut self, v: ::std::string::String) {
        self.hal = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hal(&mut self) -> &mut ::std::string::String {
        &mut self.hal
    }

    // Take field
    pub fn take_hal(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hal, ::std::string::String::new())
    }

    // .gateway.LocationMetadata location = 21;


    pub fn get_location(&self) -> &LocationMetadata {
        self.location.as_ref().unwrap_or_else(|| LocationMetadata::default_instance())
    }
    pub fn clear_location(&mut self) {
        self.location.clear();
    }

    pub fn has_location(&self) -> bool {
        self.location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: LocationMetadata) {
        self.location = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location(&mut self) -> &mut LocationMetadata {
        if self.location.is_none() {
            self.location.set_default();
        }
        self.location.as_mut().unwrap()
    }

    // Take field
    pub fn take_location(&mut self) -> LocationMetadata {
        self.location.take().unwrap_or_else(|| LocationMetadata::new())
    }

    // uint32 rtt = 31;


    pub fn get_rtt(&self) -> u32 {
        self.rtt
    }
    pub fn clear_rtt(&mut self) {
        self.rtt = 0;
    }

    // Param is passed by value, moved
    pub fn set_rtt(&mut self, v: u32) {
        self.rtt = v;
    }

    // uint32 rx_in = 41;


    pub fn get_rx_in(&self) -> u32 {
        self.rx_in
    }
    pub fn clear_rx_in(&mut self) {
        self.rx_in = 0;
    }

    // Param is passed by value, moved
    pub fn set_rx_in(&mut self, v: u32) {
        self.rx_in = v;
    }

    // uint32 rx_ok = 42;


    pub fn get_rx_ok(&self) -> u32 {
        self.rx_ok
    }
    pub fn clear_rx_ok(&mut self) {
        self.rx_ok = 0;
    }

    // Param is passed by value, moved
    pub fn set_rx_ok(&mut self, v: u32) {
        self.rx_ok = v;
    }

    // uint32 tx_in = 43;


    pub fn get_tx_in(&self) -> u32 {
        self.tx_in
    }
    pub fn clear_tx_in(&mut self) {
        self.tx_in = 0;
    }

    // Param is passed by value, moved
    pub fn set_tx_in(&mut self, v: u32) {
        self.tx_in = v;
    }

    // uint32 tx_ok = 44;


    pub fn get_tx_ok(&self) -> u32 {
        self.tx_ok
    }
    pub fn clear_tx_ok(&mut self) {
        self.tx_ok = 0;
    }

    // Param is passed by value, moved
    pub fn set_tx_ok(&mut self, v: u32) {
        self.tx_ok = v;
    }

    // uint32 lm_ok = 45;


    pub fn get_lm_ok(&self) -> u32 {
        self.lm_ok
    }
    pub fn clear_lm_ok(&mut self) {
        self.lm_ok = 0;
    }

    // Param is passed by value, moved
    pub fn set_lm_ok(&mut self, v: u32) {
        self.lm_ok = v;
    }

    // uint32 lm_st = 46;


    pub fn get_lm_st(&self) -> u32 {
        self.lm_st
    }
    pub fn clear_lm_st(&mut self) {
        self.lm_st = 0;
    }

    // Param is passed by value, moved
    pub fn set_lm_st(&mut self, v: u32) {
        self.lm_st = v;
    }

    // uint32 lm_nw = 47;


    pub fn get_lm_nw(&self) -> u32 {
        self.lm_nw
    }
    pub fn clear_lm_nw(&mut self) {
        self.lm_nw = 0;
    }

    // Param is passed by value, moved
    pub fn set_lm_nw(&mut self, v: u32) {
        self.lm_nw = v;
    }

    // uint32 l_pps = 48;


    pub fn get_l_pps(&self) -> u32 {
        self.l_pps
    }
    pub fn clear_l_pps(&mut self) {
        self.l_pps = 0;
    }

    // Param is passed by value, moved
    pub fn set_l_pps(&mut self, v: u32) {
        self.l_pps = v;
    }

    // .gateway.Status.OSMetrics os = 51;


    pub fn get_os(&self) -> &Status_OSMetrics {
        self.os.as_ref().unwrap_or_else(|| Status_OSMetrics::default_instance())
    }
    pub fn clear_os(&mut self) {
        self.os.clear();
    }

    pub fn has_os(&self) -> bool {
        self.os.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os(&mut self, v: Status_OSMetrics) {
        self.os = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os(&mut self) -> &mut Status_OSMetrics {
        if self.os.is_none() {
            self.os.set_default();
        }
        self.os.as_mut().unwrap()
    }

    // Take field
    pub fn take_os(&mut self) -> Status_OSMetrics {
        self.os.take().unwrap_or_else(|| Status_OSMetrics::new())
    }

    // repeated string messages = 52;


    pub fn get_messages(&self) -> &[::std::string::String] {
        &self.messages
    }
    pub fn clear_messages(&mut self) {
        self.messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_messages(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.messages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_messages(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.messages
    }

    // Take field
    pub fn take_messages(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.messages, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Status {
    fn is_initialized(&self) -> bool {
        for v in &self.location {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.os {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.time = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.gateway_trusted = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.boot_time = tmp;
                },
                11 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ip)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.platform)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.contact_email)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.frequency_plan)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bridge)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.router)?;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fpga = tmp;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dsp = tmp;
                },
                20 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.hal)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.location)?;
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rtt = tmp;
                },
                41 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rx_in = tmp;
                },
                42 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rx_ok = tmp;
                },
                43 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tx_in = tmp;
                },
                44 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tx_ok = tmp;
                },
                45 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.lm_ok = tmp;
                },
                46 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.lm_st = tmp;
                },
                47 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.lm_nw = tmp;
                },
                48 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.l_pps = tmp;
                },
                51 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.os)?;
                },
                52 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.messages)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(1, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.time != 0 {
            my_size += ::protobuf::rt::value_size(2, self.time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.gateway_trusted != false {
            my_size += 2;
        }
        if self.boot_time != 0 {
            my_size += ::protobuf::rt::value_size(4, self.boot_time, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.ip {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        if !self.platform.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.platform);
        }
        if !self.contact_email.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.contact_email);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.description);
        }
        if !self.frequency_plan.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.frequency_plan);
        }
        if !self.bridge.is_empty() {
            my_size += ::protobuf::rt::string_size(16, &self.bridge);
        }
        if !self.router.is_empty() {
            my_size += ::protobuf::rt::string_size(17, &self.router);
        }
        if self.fpga != 0 {
            my_size += ::protobuf::rt::value_size(18, self.fpga, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.dsp != 0 {
            my_size += ::protobuf::rt::value_size(19, self.dsp, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.hal.is_empty() {
            my_size += ::protobuf::rt::string_size(20, &self.hal);
        }
        if let Some(ref v) = self.location.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.rtt != 0 {
            my_size += ::protobuf::rt::value_size(31, self.rtt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rx_in != 0 {
            my_size += ::protobuf::rt::value_size(41, self.rx_in, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rx_ok != 0 {
            my_size += ::protobuf::rt::value_size(42, self.rx_ok, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tx_in != 0 {
            my_size += ::protobuf::rt::value_size(43, self.tx_in, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tx_ok != 0 {
            my_size += ::protobuf::rt::value_size(44, self.tx_ok, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.lm_ok != 0 {
            my_size += ::protobuf::rt::value_size(45, self.lm_ok, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.lm_st != 0 {
            my_size += ::protobuf::rt::value_size(46, self.lm_st, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.lm_nw != 0 {
            my_size += ::protobuf::rt::value_size(47, self.lm_nw, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.l_pps != 0 {
            my_size += ::protobuf::rt::value_size(48, self.l_pps, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.os.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.messages {
            my_size += ::protobuf::rt::string_size(52, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.timestamp != 0 {
            os.write_uint32(1, self.timestamp)?;
        }
        if self.time != 0 {
            os.write_int64(2, self.time)?;
        }
        if self.gateway_trusted != false {
            os.write_bool(3, self.gateway_trusted)?;
        }
        if self.boot_time != 0 {
            os.write_int64(4, self.boot_time)?;
        }
        for v in &self.ip {
            os.write_string(11, &v)?;
        };
        if !self.platform.is_empty() {
            os.write_string(12, &self.platform)?;
        }
        if !self.contact_email.is_empty() {
            os.write_string(13, &self.contact_email)?;
        }
        if !self.description.is_empty() {
            os.write_string(14, &self.description)?;
        }
        if !self.frequency_plan.is_empty() {
            os.write_string(15, &self.frequency_plan)?;
        }
        if !self.bridge.is_empty() {
            os.write_string(16, &self.bridge)?;
        }
        if !self.router.is_empty() {
            os.write_string(17, &self.router)?;
        }
        if self.fpga != 0 {
            os.write_uint32(18, self.fpga)?;
        }
        if self.dsp != 0 {
            os.write_uint32(19, self.dsp)?;
        }
        if !self.hal.is_empty() {
            os.write_string(20, &self.hal)?;
        }
        if let Some(ref v) = self.location.as_ref() {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.rtt != 0 {
            os.write_uint32(31, self.rtt)?;
        }
        if self.rx_in != 0 {
            os.write_uint32(41, self.rx_in)?;
        }
        if self.rx_ok != 0 {
            os.write_uint32(42, self.rx_ok)?;
        }
        if self.tx_in != 0 {
            os.write_uint32(43, self.tx_in)?;
        }
        if self.tx_ok != 0 {
            os.write_uint32(44, self.tx_ok)?;
        }
        if self.lm_ok != 0 {
            os.write_uint32(45, self.lm_ok)?;
        }
        if self.lm_st != 0 {
            os.write_uint32(46, self.lm_st)?;
        }
        if self.lm_nw != 0 {
            os.write_uint32(47, self.lm_nw)?;
        }
        if self.l_pps != 0 {
            os.write_uint32(48, self.l_pps)?;
        }
        if let Some(ref v) = self.os.as_ref() {
            os.write_tag(51, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.messages {
            os.write_string(52, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Status {
        Status::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timestamp",
                    |m: &Status| { &m.timestamp },
                    |m: &mut Status| { &mut m.timestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "time",
                    |m: &Status| { &m.time },
                    |m: &mut Status| { &mut m.time },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "gateway_trusted",
                    |m: &Status| { &m.gateway_trusted },
                    |m: &mut Status| { &mut m.gateway_trusted },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "boot_time",
                    |m: &Status| { &m.boot_time },
                    |m: &mut Status| { &mut m.boot_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ip",
                    |m: &Status| { &m.ip },
                    |m: &mut Status| { &mut m.ip },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "platform",
                    |m: &Status| { &m.platform },
                    |m: &mut Status| { &mut m.platform },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "contact_email",
                    |m: &Status| { &m.contact_email },
                    |m: &mut Status| { &mut m.contact_email },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "description",
                    |m: &Status| { &m.description },
                    |m: &mut Status| { &mut m.description },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "frequency_plan",
                    |m: &Status| { &m.frequency_plan },
                    |m: &mut Status| { &mut m.frequency_plan },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bridge",
                    |m: &Status| { &m.bridge },
                    |m: &mut Status| { &mut m.bridge },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "router",
                    |m: &Status| { &m.router },
                    |m: &mut Status| { &mut m.router },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fpga",
                    |m: &Status| { &m.fpga },
                    |m: &mut Status| { &mut m.fpga },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "dsp",
                    |m: &Status| { &m.dsp },
                    |m: &mut Status| { &mut m.dsp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "hal",
                    |m: &Status| { &m.hal },
                    |m: &mut Status| { &mut m.hal },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocationMetadata>>(
                    "location",
                    |m: &Status| { &m.location },
                    |m: &mut Status| { &mut m.location },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rtt",
                    |m: &Status| { &m.rtt },
                    |m: &mut Status| { &mut m.rtt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rx_in",
                    |m: &Status| { &m.rx_in },
                    |m: &mut Status| { &mut m.rx_in },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rx_ok",
                    |m: &Status| { &m.rx_ok },
                    |m: &mut Status| { &mut m.rx_ok },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tx_in",
                    |m: &Status| { &m.tx_in },
                    |m: &mut Status| { &mut m.tx_in },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tx_ok",
                    |m: &Status| { &m.tx_ok },
                    |m: &mut Status| { &mut m.tx_ok },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "lm_ok",
                    |m: &Status| { &m.lm_ok },
                    |m: &mut Status| { &mut m.lm_ok },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "lm_st",
                    |m: &Status| { &m.lm_st },
                    |m: &mut Status| { &mut m.lm_st },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "lm_nw",
                    |m: &Status| { &m.lm_nw },
                    |m: &mut Status| { &mut m.lm_nw },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "l_pps",
                    |m: &Status| { &m.l_pps },
                    |m: &mut Status| { &mut m.l_pps },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Status_OSMetrics>>(
                    "os",
                    |m: &Status| { &m.os },
                    |m: &mut Status| { &mut m.os },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "messages",
                    |m: &Status| { &m.messages },
                    |m: &mut Status| { &mut m.messages },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Status>(
                    "Status",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Status {
        static mut instance: ::protobuf::lazy::Lazy<Status> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Status,
        };
        unsafe {
            instance.get(Status::new)
        }
    }
}

impl ::protobuf::Clear for Status {
    fn clear(&mut self) {
        self.timestamp = 0;
        self.time = 0;
        self.gateway_trusted = false;
        self.boot_time = 0;
        self.ip.clear();
        self.platform.clear();
        self.contact_email.clear();
        self.description.clear();
        self.frequency_plan.clear();
        self.bridge.clear();
        self.router.clear();
        self.fpga = 0;
        self.dsp = 0;
        self.hal.clear();
        self.location.clear();
        self.rtt = 0;
        self.rx_in = 0;
        self.rx_ok = 0;
        self.tx_in = 0;
        self.tx_ok = 0;
        self.lm_ok = 0;
        self.lm_st = 0;
        self.lm_nw = 0;
        self.l_pps = 0;
        self.os.clear();
        self.messages.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Status {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Status {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Status_OSMetrics {
    // message fields
    pub load_1: f32,
    pub load_5: f32,
    pub load_15: f32,
    pub cpu_percentage: f32,
    pub memory_percentage: f32,
    pub temperature: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Status_OSMetrics {
    fn default() -> &'a Status_OSMetrics {
        <Status_OSMetrics as ::protobuf::Message>::default_instance()
    }
}

impl Status_OSMetrics {
    pub fn new() -> Status_OSMetrics {
        ::std::default::Default::default()
    }

    // float load_1 = 1;


    pub fn get_load_1(&self) -> f32 {
        self.load_1
    }
    pub fn clear_load_1(&mut self) {
        self.load_1 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_load_1(&mut self, v: f32) {
        self.load_1 = v;
    }

    // float load_5 = 2;


    pub fn get_load_5(&self) -> f32 {
        self.load_5
    }
    pub fn clear_load_5(&mut self) {
        self.load_5 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_load_5(&mut self, v: f32) {
        self.load_5 = v;
    }

    // float load_15 = 3;


    pub fn get_load_15(&self) -> f32 {
        self.load_15
    }
    pub fn clear_load_15(&mut self) {
        self.load_15 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_load_15(&mut self, v: f32) {
        self.load_15 = v;
    }

    // float cpu_percentage = 11;


    pub fn get_cpu_percentage(&self) -> f32 {
        self.cpu_percentage
    }
    pub fn clear_cpu_percentage(&mut self) {
        self.cpu_percentage = 0.;
    }

    // Param is passed by value, moved
    pub fn set_cpu_percentage(&mut self, v: f32) {
        self.cpu_percentage = v;
    }

    // float memory_percentage = 21;


    pub fn get_memory_percentage(&self) -> f32 {
        self.memory_percentage
    }
    pub fn clear_memory_percentage(&mut self) {
        self.memory_percentage = 0.;
    }

    // Param is passed by value, moved
    pub fn set_memory_percentage(&mut self, v: f32) {
        self.memory_percentage = v;
    }

    // float temperature = 31;


    pub fn get_temperature(&self) -> f32 {
        self.temperature
    }
    pub fn clear_temperature(&mut self) {
        self.temperature = 0.;
    }

    // Param is passed by value, moved
    pub fn set_temperature(&mut self, v: f32) {
        self.temperature = v;
    }
}

impl ::protobuf::Message for Status_OSMetrics {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.load_1 = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.load_5 = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.load_15 = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.cpu_percentage = tmp;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.memory_percentage = tmp;
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.temperature = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.load_1 != 0. {
            my_size += 5;
        }
        if self.load_5 != 0. {
            my_size += 5;
        }
        if self.load_15 != 0. {
            my_size += 5;
        }
        if self.cpu_percentage != 0. {
            my_size += 5;
        }
        if self.memory_percentage != 0. {
            my_size += 6;
        }
        if self.temperature != 0. {
            my_size += 6;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.load_1 != 0. {
            os.write_float(1, self.load_1)?;
        }
        if self.load_5 != 0. {
            os.write_float(2, self.load_5)?;
        }
        if self.load_15 != 0. {
            os.write_float(3, self.load_15)?;
        }
        if self.cpu_percentage != 0. {
            os.write_float(11, self.cpu_percentage)?;
        }
        if self.memory_percentage != 0. {
            os.write_float(21, self.memory_percentage)?;
        }
        if self.temperature != 0. {
            os.write_float(31, self.temperature)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Status_OSMetrics {
        Status_OSMetrics::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "load_1",
                    |m: &Status_OSMetrics| { &m.load_1 },
                    |m: &mut Status_OSMetrics| { &mut m.load_1 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "load_5",
                    |m: &Status_OSMetrics| { &m.load_5 },
                    |m: &mut Status_OSMetrics| { &mut m.load_5 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "load_15",
                    |m: &Status_OSMetrics| { &m.load_15 },
                    |m: &mut Status_OSMetrics| { &mut m.load_15 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "cpu_percentage",
                    |m: &Status_OSMetrics| { &m.cpu_percentage },
                    |m: &mut Status_OSMetrics| { &mut m.cpu_percentage },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "memory_percentage",
                    |m: &Status_OSMetrics| { &m.memory_percentage },
                    |m: &mut Status_OSMetrics| { &mut m.memory_percentage },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "temperature",
                    |m: &Status_OSMetrics| { &m.temperature },
                    |m: &mut Status_OSMetrics| { &mut m.temperature },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Status_OSMetrics>(
                    "Status_OSMetrics",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Status_OSMetrics {
        static mut instance: ::protobuf::lazy::Lazy<Status_OSMetrics> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Status_OSMetrics,
        };
        unsafe {
            instance.get(Status_OSMetrics::new)
        }
    }
}

impl ::protobuf::Clear for Status_OSMetrics {
    fn clear(&mut self) {
        self.load_1 = 0.;
        self.load_5 = 0.;
        self.load_15 = 0.;
        self.cpu_percentage = 0.;
        self.memory_percentage = 0.;
        self.temperature = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Status_OSMetrics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Status_OSMetrics {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n5github.com/TheThingsNetwork/api/gateway/gateway.proto\x12\x07gateway\
    \x1a-github.com/gogo/protobuf/gogoproto/gogo.proto\"\xb0\x02\n\x10Locati\
    onMetadata\x12\x12\n\x04time\x18\x01\x20\x01(\x03R\x04time\x12\x1a\n\x08\
    latitude\x18\x02\x20\x01(\x02R\x08latitude\x12\x1c\n\tlongitude\x18\x03\
    \x20\x01(\x02R\tlongitude\x12\x1a\n\x08altitude\x18\x04\x20\x01(\x05R\
    \x08altitude\x12\x1a\n\x08accuracy\x18\x05\x20\x01(\x05R\x08accuracy\x12\
    @\n\x06source\x18\x06\x20\x01(\x0e2(.gateway.LocationMetadata.LocationSo\
    urceR\x06source\"T\n\x0eLocationSource\x12\x0b\n\x07UNKNOWN\x10\0\x12\
    \x07\n\x03GPS\x10\x01\x12\n\n\x06CONFIG\x10\x02\x12\x0c\n\x08REGISTRY\
    \x10\x03\x12\x12\n\x0eIP_GEOLOCATION\x10\x04\"\xa7\x06\n\nRxMetadata\x12\
    ,\n\ngateway_id\x18\x01\x20\x01(\tR\tgatewayIdB\r\xe2\xde\x1f\tGatewayID\
    \x12'\n\x0fgateway_trusted\x18\x02\x20\x01(\x08R\x0egatewayTrusted\x12\
    \x1c\n\ttimestamp\x18\x0b\x20\x01(\rR\ttimestamp\x12\x12\n\x04time\x18\
    \x0c\x20\x01(\x03R\x04time\x12%\n\x0eencrypted_time\x18\r\x20\x01(\x0cR\
    \rencryptedTime\x12\x19\n\x08rf_chain\x18\x15\x20\x01(\rR\x07rfChain\x12\
    \x18\n\x07channel\x18\x16\x20\x01(\rR\x07channel\x127\n\x08antennas\x18\
    \x1e\x20\x03(\x0b2\x1b.gateway.RxMetadata.AntennaR\x08antennas\x12\x1c\n\
    \tfrequency\x18\x1f\x20\x01(\x04R\tfrequency\x12\x1c\n\x04rssi\x18\x20\
    \x20\x01(\x02R\x04rssiB\x08\xe2\xde\x1f\x04RSSI\x12\x19\n\x03snr\x18!\
    \x20\x01(\x02R\x03snrB\x07\xe2\xde\x1f\x03SNR\x125\n\x08location\x18)\
    \x20\x01(\x0b2\x19.gateway.LocationMetadataR\x08location\x1a\xec\x02\n\
    \x07Antenna\x12\x18\n\x07antenna\x18\x01\x20\x01(\rR\x07antenna\x12\x18\
    \n\x07channel\x18\x02\x20\x01(\rR\x07channel\x12\x1c\n\x04rssi\x18\x03\
    \x20\x01(\x02R\x04rssiB\x08\xe2\xde\x1f\x04RSSI\x122\n\x0cchannel_rssi\
    \x18\x05\x20\x01(\x02R\x0bchannelRssiB\x0f\xe2\xde\x1f\x0bChannelRSSI\
    \x12Q\n\x17rssi_standard_deviation\x18\x06\x20\x01(\x02R\x15rssiStandard\
    DeviationB\x19\xe2\xde\x1f\x15RSSIStandardDeviation\x12)\n\x10frequency_\
    offset\x18\x07\x20\x01(\x03R\x0ffrequencyOffset\x12\x19\n\x03snr\x18\x04\
    \x20\x01(\x02R\x03snrB\x07\xe2\xde\x1f\x03SNR\x12%\n\x0eencrypted_time\
    \x18\n\x20\x01(\x0cR\rencryptedTime\x12\x1b\n\tfine_time\x18\x0b\x20\x01\
    (\x03R\x08fineTime\"\xe6\x01\n\x0fTxConfiguration\x12\x1c\n\ttimestamp\
    \x18\x0b\x20\x01(\rR\ttimestamp\x12\x19\n\x08rf_chain\x18\x15\x20\x01(\r\
    R\x07rfChain\x12\x1c\n\tfrequency\x18\x16\x20\x01(\x04R\tfrequency\x12\
    \x14\n\x05power\x18\x17\x20\x01(\x05R\x05power\x125\n\x16polarization_in\
    version\x18\x1f\x20\x01(\x08R\x15polarizationInversion\x12/\n\x13frequen\
    cy_deviation\x18\x20\x20\x01(\rR\x12frequencyDeviation\"\xd7\x07\n\x06St\
    atus\x12\x1c\n\ttimestamp\x18\x01\x20\x01(\rR\ttimestamp\x12\x12\n\x04ti\
    me\x18\x02\x20\x01(\x03R\x04time\x12'\n\x0fgateway_trusted\x18\x03\x20\
    \x01(\x08R\x0egatewayTrusted\x12\x1b\n\tboot_time\x18\x04\x20\x01(\x03R\
    \x08bootTime\x12\x16\n\x02ip\x18\x0b\x20\x03(\tR\x02ipB\x06\xe2\xde\x1f\
    \x02IP\x12\x1a\n\x08platform\x18\x0c\x20\x01(\tR\x08platform\x12#\n\rcon\
    tact_email\x18\r\x20\x01(\tR\x0ccontactEmail\x12\x20\n\x0bdescription\
    \x18\x0e\x20\x01(\tR\x0bdescription\x12%\n\x0efrequency_plan\x18\x0f\x20\
    \x01(\tR\rfrequencyPlan\x12\x16\n\x06bridge\x18\x10\x20\x01(\tR\x06bridg\
    e\x12\x16\n\x06router\x18\x11\x20\x01(\tR\x06router\x12\x1c\n\x04fpga\
    \x18\x12\x20\x01(\rR\x04fpgaB\x08\xe2\xde\x1f\x04FPGA\x12\x19\n\x03dsp\
    \x18\x13\x20\x01(\rR\x03dspB\x07\xe2\xde\x1f\x03DSP\x12\x19\n\x03hal\x18\
    \x14\x20\x01(\tR\x03halB\x07\xe2\xde\x1f\x03HAL\x125\n\x08location\x18\
    \x15\x20\x01(\x0b2\x19.gateway.LocationMetadataR\x08location\x12\x19\n\
    \x03rtt\x18\x1f\x20\x01(\rR\x03rttB\x07\xe2\xde\x1f\x03RTT\x12\x13\n\x05\
    rx_in\x18)\x20\x01(\rR\x04rxIn\x12\x13\n\x05rx_ok\x18*\x20\x01(\rR\x04rx\
    Ok\x12\x13\n\x05tx_in\x18+\x20\x01(\rR\x04txIn\x12\x13\n\x05tx_ok\x18,\
    \x20\x01(\rR\x04txOk\x12\x13\n\x05lm_ok\x18-\x20\x01(\rR\x04lmOk\x12\x13\
    \n\x05lm_st\x18.\x20\x01(\rR\x04lmSt\x12\x13\n\x05lm_nw\x18/\x20\x01(\rR\
    \x04lmNw\x12\x1d\n\x05l_pps\x180\x20\x01(\rR\x04lPpsB\x08\xe2\xde\x1f\
    \x04LPPS\x121\n\x02os\x183\x20\x01(\x0b2\x19.gateway.Status.OSMetricsR\
    \x02osB\x06\xe2\xde\x1f\x02OS\x12\x1a\n\x08messages\x184\x20\x03(\tR\x08\
    messages\x1a\xdb\x01\n\tOSMetrics\x12\x15\n\x06load_1\x18\x01\x20\x01(\
    \x02R\x05load1\x12\x15\n\x06load_5\x18\x02\x20\x01(\x02R\x05load5\x12\
    \x17\n\x07load_15\x18\x03\x20\x01(\x02R\x06load15\x128\n\x0ecpu_percenta\
    ge\x18\x0b\x20\x01(\x02R\rcpuPercentageB\x11\xe2\xde\x1f\rCPUPercentage\
    \x12+\n\x11memory_percentage\x18\x15\x20\x01(\x02R\x10memoryPercentage\
    \x12\x20\n\x0btemperature\x18\x1f\x20\x01(\x02R\x0btemperatureBz\n\x20or\
    g.thethingsnetwork.api.gatewayB\x0cGatewayProtoP\x01Z'github.com/TheThin\
    gsNetwork/api/gateway\xaa\x02\x1cTheThingsNetwork.API.Gatewayb\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
